<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link href="https://fonts.googleapis.com/css2?family=Sour+Gummy&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Honk&display=swap" rel="stylesheet">

    <title>Fruit Merge Game with Firebase</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            position: relative;
            font-family: 'Sour Gummy', sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <!-- Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>

    <!-- Firebase App (compat) -->
    <script src="https://www.gstatic.com/firebasejs/9.21.0/firebase-app-compat.js"></script>
    <!-- If you want to use Analytics -->
    <script src="https://www.gstatic.com/firebasejs/9.21.0/firebase-analytics-compat.js"></script>

    <script>
        // Your Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyC1UkIoa4YLssMC0sQDAqFmqneIJ7PpCsU",
          authDomain: "fruit-merge-idc-game.firebaseapp.com",
          projectId: "fruit-merge-idc-game",
          storageBucket: "fruit-merge-idc-game.firebasestorage.app",
          messagingSenderId: "581122347526",
          appId: "1:581122347526:web:7d120f38a40c60a7c2e987",
          measurementId: "G-VDD7CG94Y2"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        firebase.analytics();

        // Shortcuts to Matter.js
        var Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Composite = Matter.Composite,
            Bodies = Matter.Bodies,
            Events = Matter.Events;

        var engine = Engine.create(),
            world = engine.world;

        var render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: 1300,
                height: 1000,
                wireframes: false,
                background: '#ccebff'
            }
        });

        Render.run(render);
        var runner = Runner.create();
        Runner.run(runner, engine);

        // Cup setup
        var cupCenterX = 500; 
        var cupCenterY = 420;
        var cupWidthTop = 400;
        var cupWidthBottom = 300;
        var cupHeight = 300;
        var cupBottomY = cupCenterY + cupHeight / 2;
        
        var level = 1;

        var bottom = Bodies.rectangle(cupCenterX, cupCenterY + cupHeight / 2, cupWidthBottom, 40, {
            isStatic: true,
            render: { fillStyle: '#555' }
        });

        var angle = Math.atan((cupWidthTop - cupWidthBottom) / (2 * cupHeight));

        var leftWall = Bodies.rectangle(
            cupCenterX - cupWidthBottom / 2 - 20,
            cupCenterY,
            cupHeight,
            40,
            {
                isStatic: true,
                angle: -Math.PI / 2 - angle,
                render: { fillStyle: '#555' }
            }
        );

        var rightWall = Bodies.rectangle(
            cupCenterX + cupWidthBottom / 2 + 20,
            cupCenterY,
            cupHeight,
            40,
            {
                isStatic: true,
                angle: Math.PI / 2 + angle,
                render: { fillStyle: '#555' }
            }
        );

        Composite.add(world, [bottom, leftWall, rightWall]);

        var guideLine = { x: 500, y: 200 };

        // Mouse movement controls
document.addEventListener('mousemove', function(event) {
    var canvasRect = render.canvas.getBoundingClientRect();
    var mouseX = event.clientX - canvasRect.left;

    var leftLimit = 500 - (cupWidthTop / 2) + 20;
    var rightLimit = 500 + (cupWidthTop / 2) - 20;

    // Update guideLine.x based on mouse movement, within limits
    if (mouseX > leftLimit && mouseX < rightLimit) {
        guideLine.x = mouseX;
    }
});

// Mouse click to drop fruit
document.addEventListener('click', function(event) {
    var canvasRect = render.canvas.getBoundingClientRect();
    var mouseX = event.clientX - canvasRect.left;
    var mouseY = event.clientY - canvasRect.top;

    // Only drop the fruit if the click is within the game area
    if (
        mouseX > 0 && mouseX < canvasRect.width &&
        mouseY > 0 && mouseY < canvasRect.height
    ) {
        dropFruit();
    }
});


        let coins = 0; // Track the number of coins

        // 4-level fruit hierarchy
        var fruitHierarchy = {
            'Strawberry': {
                levels: [
                    { color: '#FC8694', radius: 15 },
                    { color: '#FB576A', radius: 20 },
                    { color: '#F92740', radius: 25 },
                    { color: '#DE2339', radius: 30 }
                ]
            },
            'Banana': {
                levels: [
                    { color: '#FFF4BB', radius: 15 },
                    { color: '#FFEE8F', radius: 20 },
                    { color: '#FFE762', radius: 25 },
                    { color: '#FFE135', radius: 30 }
                ]
            },
            'Blueberry': {
                levels: [
                    { color: '#7772B9', radius: 15 },
                    { color: '#554FA2', radius: 20 },
                    { color: '#464096', radius: 25 },
                    { color: '#2E2B64', radius: 30 }
                ]
            },
            'Kiwi': {
                levels: [
                    { color: '#c08459', radius: 15 },
                    { color: '#a66a3f', radius: 20 },
                    { color: '#8e5b36', radius: 25 },
                    { color: '#6f472a', radius: 30 }
                ]
            },
            'Orange': {
                levels: [
                    { color: '#ffcc80', radius: 15 },
                    { color: '#ffad33', radius: 20 },
                    { color: '#ff9900', radius: 25 },
                    { color: '#ff8000', radius: 30 }
                ]
            },
            'Grape': {
                levels: [
                    { color: '#B677AB', radius: 15 },
                    { color: '#924685', radius: 20 },
                    { color: '#6D2161', radius: 25 },
                    { color: '#5B144F', radius: 30 }   
                ]
            }
        };

        var allFruits = Object.keys(fruitHierarchy);

                // Add customers array
                var customers = [
                { id: 1, fruit: getRandomFruitType(), level: 3, fulfilled: false },
                { id: 2, fruit: getRandomFruitType(), level: 2, fulfilled: false },
                { id: 3, fruit: getRandomFruitType(), level: 1, fulfilled: false }
            ];

            function drawCustomers(ctx) {
    var startX = 250;
    var startY = cupCenterY + cupHeight / 2 - 520;
    var horizontalSpacing = 200;

    ctx.font = "20px 'Sour Gummy', sans-serif";
    ctx.fillStyle = "black";
    ctx.fillText("Customer:", startX, startY);

    customers.forEach((customer, index) => {
        var xPos = startX + index * horizontalSpacing;
        ctx.fillStyle = customer.fulfilled ? "green" : "black";
        ctx.fillText(`Customer ${customer.id}:`, xPos, startY);

        if (!customer.fulfilled) {
            var type = fruitHierarchy[customer.fruit];
            var lvlData = type.levels[customer.level];

            ctx.beginPath();
            ctx.arc(xPos + 50, startY + 40, lvlData.radius, 0, 2 * Math.PI);
            ctx.fillStyle = lvlData.color;
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.stroke();

            // Determine text color
            const textColor = getContrastColor(lvlData.color);

            // Add hierarchy text
            ctx.font = "16px 'Sour Gummy', sans-serif";
            ctx.fillStyle = textColor;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText((customer.level + 1) + "x", xPos + 50, startY + 40);
        }
    });
}



        function showPopupAndProceed() {
            // Check if the popup already exists to avoid duplicates
            if (document.getElementById('popup')) return;

            // Add 10 coins when the level is completed
            coins += 10;

            // Create a popup overlay
            var popup = document.createElement('div');
            popup.id = 'popup'; // Add an ID to the popup for easy reference
            popup.style.position = 'absolute';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.padding = '20px';
            popup.style.backgroundColor = 'white';
            popup.style.border = '2px solid black';
            popup.style.zIndex = '1000';
            popup.innerHTML = `
                <p>Congratulations! You've completed this level!</p>
                <p>You have earned 10 coins!</p>
                <p>Total Coins: ${coins}</p>
                <button id="nextLevelBtn">Next Level</button>
            `;
            document.body.appendChild(popup);

            // Ensure the button event is correctly attached after the popup is added
            var nextLevelButton = document.getElementById('nextLevelBtn');
            if (nextLevelButton) {
                nextLevelButton.addEventListener('click', function () {
                    // Remove the popup
                    var popup = document.getElementById('popup');
                    if (popup) {
                        document.body.removeChild(popup);
                    }

                    // Increment the level
                    level++;

                    // Reset customers and clear the cup
                    resetCustomers();
                });
            }
        }

        function showLossPopup() {
            // Check if the popup already exists to avoid duplicates
            if (document.getElementById('lossPopup')) return;

            // 3.2. Create a loss popup overlay
            var popup = document.createElement('div');
            popup.id = 'lossPopup'; // Add an ID to the popup for easy reference
            popup.style.position = 'absolute';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.padding = '20px';
            popup.style.backgroundColor = 'white';
            popup.style.border = '2px solid black';
            popup.style.zIndex = '1000';
            popup.innerHTML = `
                <p>You Lost! A fruit fell out of the cup.</p>
                <button id="restartLevelBtn">Restart Level</button>
            `;
            document.body.appendChild(popup);

            // 3.3. Attach event to restart the level when the button is clicked
            var restartLevelButton = document.getElementById('restartLevelBtn');
            if (restartLevelButton) {
                restartLevelButton.addEventListener('click', function () {
                    // Remove the popup
                    var popup = document.getElementById('lossPopup');
                    if (popup) {
                        document.body.removeChild(popup);
                    }

                    // Restart the level
                    resetLevel();
                });
            }
        }

        function resetLevel() {
            // 4.2. Reset the level (you can modify this to maintain the current level if needed)
            level = 1; // Reset to the starting level (or the current level if needed)
            coins = 0; // Reset coins (optional)

            // 4.3. Reset customers
            resetCustomers();

            // 4.4. Clear the cup by removing all fruit bodies from the Matter.js world
            Composite.allBodies(world).forEach(body => {
                if (body.fruitType) {
                    Composite.remove(world, body);
                }
            });

            console.log("Level restarted and cup cleared.");
        }

        function resetCustomers() {
            // Reset customers
            customers = [
                { id: 1, fruit: getRandomFruitType(), level: 3, fulfilled: false },
                { id: 2, fruit: getRandomFruitType(), level: 2, fulfilled: false },
                { id: 3, fruit: getRandomFruitType(), level: 1, fulfilled: false }
            ];

            // Clear the cup by removing all fruit bodies from the Matter.js world
            Composite.allBodies(world).forEach(body => {
                if (body.fruitType) { // Only remove bodies that represent fruits
                    Composite.remove(world, body);
                }
            });

            console.log("Cup cleared and customers reset for the next level.");
        }

        function checkAllCustomersFulfilled() {
            return customers.every(customer => customer.fulfilled);
        }

        function checkCustomerRequests(fruit) {
            customers.forEach((customer) => {
                if (
                    !customer.fulfilled &&
                    customer.fruit === fruit.fruitType &&
                    customer.level === fruit.fruitLevel
                ) {
                    customer.fulfilled = true;
                    Composite.remove(world, fruit);
                }
            });

            // Check if all customers are fulfilled
            if (checkAllCustomersFulfilled()) {
                showPopupAndProceed();
            }
        }

        function getRandomFruitType() {
            return allFruits[Math.floor(Math.random() * allFruits.length)];
        }

        function getRandomFruitEntry() {
            return { type: getRandomFruitType(), level: 0 };
        }

        var upcomingFruits = [getRandomFruitEntry(), getRandomFruitEntry(), getRandomFruitEntry(), getRandomFruitEntry(), getRandomFruitEntry()];
        function currentFruit() {
            return upcomingFruits[0];
        } 

        var moveLeft = false;
        var moveRight = false;
        var moveSpeed = 5;


        function dropFruit() {
            var curr = currentFruit();
            var fruit = createFruit(guideLine.x, 200, curr.type, curr.level);
            Composite.add(world, fruit);
            analyzeCup();

            upcomingFruits.shift();
            upcomingFruits.push(getRandomFruitEntry());
        }

        function getContrastColor(hexColor) {
    // Convert hex to RGB
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);

    // Calculate luminance
    const luminance = 0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255);

    // Return black or white based on luminance
    return luminance > 0.5 ? "black" : "white";
}

        function createFruit(x, y, fruitType, level) {
    var type = fruitHierarchy[fruitType];
    var lvlData = type.levels[level];
    var fruit = Bodies.circle(x, y, lvlData.radius, {
        restitution: 0.5,
        label: fruitType,
        render: {
            fillStyle: lvlData.color
        }
    });

    fruit.fruitType = fruitType;
    fruit.fruitLevel = level;
    fruit.hierarchyText = (level + 1) + "x"; // Add the hierarchy text (e.g., 1x, 2x, 3x)
    return fruit;
}
        function analyzeCup() {
            var fruitCounts = {};
            Composite.allBodies(world).forEach(function(body) {
                if (body.fruitType) {
                    var key = body.fruitType + "_L" + body.fruitLevel;
                    if (!fruitCounts[key]) fruitCounts[key] = 0;
                    fruitCounts[key]++;

                    // 2.2. Check if the fruit has fallen out of the cup
                    if (body.position.y > cupBottomY) {
                        // Player loses if a fruit falls out of the cup
                        showLossPopup();
                    }
                }
            });
            console.log("Current fruits in cup:", fruitCounts);
        }

        function drawFruitsWithText(ctx) {
    Composite.allBodies(world).forEach(function (body) {
        if (body.fruitType) {
            // Get the fruit's properties
            var posX = body.position.x;
            var posY = body.position.y;
            var radius = fruitHierarchy[body.fruitType].levels[body.fruitLevel].radius;
            var bgColor = fruitHierarchy[body.fruitType].levels[body.fruitLevel].color;

            // Determine the contrast color for the text
            const textColor = getContrastColor(bgColor);

            // Draw the hierarchy text inside the fruit
            ctx.font = "16px 'Sour Gummy', sans-serif";
            ctx.fillStyle = textColor;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(body.hierarchyText, posX, posY);

            // Optional: Debug circle (not visible in game)
            // ctx.beginPath();
            // ctx.arc(posX, posY, radius, 0, 2 * Math.PI);
            // ctx.stroke();
        }
    });
}



        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowLeft') {
                moveLeft = true;
            } else if (event.key === 'ArrowRight') {
                moveRight = true;
            } else if (event.key === ' ') {
                dropFruit();
            }
        });

        document.addEventListener('keyup', function(event) {
            if (event.key === 'ArrowLeft') {
                moveLeft = false;
            } else if (event.key === 'ArrowRight') {
                moveRight = false;
            }
        });

        function mergeFruits(bodyA, bodyB) {
            var fruitType = bodyA.fruitType;
            var level = bodyA.fruitLevel;
            var typeData = fruitHierarchy[fruitType];
            var maxLevel = typeData.levels.length - 1; // Dynamically get the max level

            // Remove the two fruits that are merging
            Composite.remove(world, bodyA);
            Composite.remove(world, bodyB);

            // Add coins only if the fruits were at max level
            if (level == maxLevel) {
                coins += 5;
                console.log("5 coins added for max level fruits! Total coins: " + coins);
            }

            if (level < maxLevel) {
                // Create a new merged fruit with a higher level
                var newX = (bodyA.position.x + bodyB.position.x) / 2;
                var newY = (bodyA.position.y + bodyB.position.y) / 2;
                var mergedFruit = createFruit(newX, newY, fruitType, level + 1);
                Composite.add(world, mergedFruit);
            }
        }
        Events.on(engine, 'collisionStart', function (event) {
            var pairs = event.pairs;
            pairs.forEach(function (pair) {
                var bodyA = pair.bodyA;
                var bodyB = pair.bodyB;

                if (bodyA.fruitType && bodyB.fruitType) {
                    if (bodyA.fruitType === bodyB.fruitType && bodyA.fruitLevel === bodyB.fruitLevel) {
                        mergeFruits(bodyA, bodyB);
                    }
                }

                // Check customer requests for fruits involved in collisions
                if (bodyA.fruitType) checkCustomerRequests(bodyA);
                if (bodyB.fruitType) checkCustomerRequests(bodyB);
            });
        });

        function drawGuideLine(ctx) {
    ctx.beginPath();
    ctx.moveTo(guideLine.x, 240);
    ctx.lineTo(guideLine.x, 400);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);

    var curr = currentFruit();
    var type = fruitHierarchy[curr.type];
    var lvlData = type.levels[curr.level];

    // Draw the preview fruit
    ctx.beginPath();
    ctx.arc(guideLine.x, 200, lvlData.radius, 0, 2 * Math.PI);
    ctx.fillStyle = lvlData.color;
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.stroke();

    // Determine text color based on fruit color
    const textColor = getContrastColor(lvlData.color);

    // Add hierarchy text inside the fruit
    ctx.font = "16px 'Sour Gummy', sans-serif";
    ctx.fillStyle = textColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText((curr.level + 1) + "x", guideLine.x, 200);

    // Draw the fruit type label below the fruit
    ctx.fillStyle = "black";
    ctx.font = "18px 'Sour Gummy', sans-serif";
    ctx.fillText(curr.type + " L" + (curr.level + 1), guideLine.x - 40, 230);
}


function drawUpcomingFruits(ctx) {
    var startX = 60; 
    var startY = 350;
    var verticalSpacing = 70;

    ctx.font = "20px 'Sour Gummy', sans-serif";
    ctx.fillStyle = "black";
    ctx.fillText("Upcoming:", startX - 20, startY - 50);

    for (var i = 1; i < upcomingFruits.length; i++) {
        var fruitData = upcomingFruits[i];
        var type = fruitHierarchy[fruitData.type];
        var lvlData = type.levels[fruitData.level]; 
        var yPos = startY + (i - 1) * verticalSpacing;

        // Draw the fruit circle
        ctx.beginPath();
        ctx.arc(startX, yPos, lvlData.radius, 0, 2 * Math.PI);
        ctx.fillStyle = lvlData.color;
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.stroke();

        // Determine text color for optimal contrast
        const textColor = getContrastColor(lvlData.color);

        // Add hierarchy text inside the fruit
        ctx.font = "16px 'Sour Gummy', sans-serif";
        ctx.fillStyle = textColor;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText((fruitData.level + 1) + "x", startX, yPos);
    }
}


        function drawCurrentLevel(ctx) {
            ctx.font = "40px 'Honk', sans-serif";
            ctx.fillStyle = "black";
            ctx.fillText("Level: " + level, 30, 30);
        }
        function displayCoins(ctx) {
            ctx.font = "40px 'Honk', sans-serif";
            ctx.fillStyle = "black";
            ctx.fillText("Coins: " + coins, 30, 80);
        }

        (function renderLoop() {
    var leftLimit = 500 - (cupWidthTop / 2) + 20;
    var rightLimit = 500 + (cupWidthTop / 2) - 20;

    if (moveLeft && guideLine.x > leftLimit) {
        guideLine.x -= moveSpeed;
    }
    if (moveRight && guideLine.x < rightLimit) {
        guideLine.x += moveSpeed;
    }

    var context = render.context;
    context.clearRect(0, 0, render.canvas.width, render.canvas.height);
    Render.world(render);

    drawGuideLine(context);
    drawUpcomingFruits(context);
    drawCustomers(context);
    drawCurrentLevel(context); 
    displayCoins(context);

    // Draw fruits with hierarchy text
    drawFruitsWithText(context);

    analyzeCup(); // Check for out-of-cup fruits
    requestAnimationFrame(renderLoop);
})();


    </script>
</body>
</html>
