<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=1024, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Fruit Merge Game + Pachinko</title>
 
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Sour+Gummy&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Honk&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">

 
  <!-- Matter.js (for the main Fruit Merge game) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.21.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.21.0/firebase-analytics-compat.js"></script>
 
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000; /* Optional fallback */
      overflow: hidden;       /* Disable scrolling */
      width: 1300px;         /* Fixed layout width */
      height: 768px;         /* Fixed layout height */
    }
 
    /* Fixed background layer */
    #background-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 1300px;
      height: 731px;
      background-image: url('background7.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      z-index: -1; /* Keep behind everything else */
    }
 
    /* Main game container is also fixed to avoid movement */
    #game-container {
      position: fixed;        /* Pin to the top-left to match the background */
      top: 0;
      left: 0;
      width: 1024px;
      height: 768px;
      overflow: hidden;
      transform: scale(0.9); /* Scale down to 90% */
      transform-origin: top left;
    }
 
    canvas {
      display: block;
      width: 1024px;  /* Fixed canvas width */
      height: 768px; /* Fixed canvas height */
    }
 
    .pachinko-container {
      position: absolute;
      top: 100px; /* Adjust as needed */
      left: 800px;
      width: 320px;
      height: 500px;
      pointer-events: none;  /* Let clicks pass through (if desired) */
    }
 
    #pachinkoCanvas {
      width: 320px;
      height: 500px;
      background: transparent;
      pointer-events: auto;  /* Re-enable clicks on this canvas */
      border: 2px solid rgba(255,255,255,0.2);
    }

    .popupBox {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: url('Banner.png') no-repeat center center; /* Use the banner as the background */
  background-size: contain; /* Ensure the image scales properly */
  width: 600px; /* Adjust width to match banner */
  height: 403px; /* Adjust height to match banner */
  display: flex;
  flex-direction: column ;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 20px;
  box-sizing: border-box;
  font-family: 'Fredoka One', sans-serif; /* Consistent font styling */
  color: black; /* Text color for better readability */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add a subtle shadow */
}

.popupBox h2 {
  font-size: 26px; 
  margin: 0 0 10px;
}

.popupBox p {
  font-size: 18px;
  margin: 5px 0;
}

.popupBox button {
  font-size: 18px;
  font-family: 'Honk', sans-serif;
  padding: 10px 20px;
  background-color: #f0c040; /* Button background color */
  color: black; /* Button text color */
  border: none;
  border-radius: 5px;
  margin-top: 15px;
  cursor: pointer;
  transition: background-color 0.2s;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.popupBox button:hover {
  background-color: #e0b030; /* Slightly darker color on hover */
}

  </style>
</head>
 
<body>
  <div id="background-layer"></div>
  <div id="game-container"></div>
 
  <!-- Pachinko container & canvas -->
  <div class="pachinko-container">
    <canvas id="pachinkoCanvas"></canvas>
  </div>
 
  <script>
    /**************************************************************
     * 1) Firebase Initialization
     **************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyC1UkIoa4YLssMC0sQDAqFmqneIJ7PpCsU",
      authDomain: "fruit-merge-idc-game.firebaseapp.com",
      projectId: "fruit-merge-idc-game",
      storageBucket: "fruit-merge-idc-game.firebasestorage.app",
      messagingSenderId: "581122347526",
      appId: "1:581122347526:web:7d120f38a40c60a7c2e987",
      measurementId: "G-VDD7CG94Y2"
    };
    firebase.initializeApp(firebaseConfig);
    firebase.analytics();
 
    /**************************************************************
     * 2) Main Fruit Merge Game with Matter.js
     **************************************************************/
    var Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Composite = Matter.Composite,
        Bodies = Matter.Bodies,
        Events = Matter.Events;
 
    var engine = Engine.create(),
        world = engine.world;
 
    var render = Matter.Render.create({
      element: document.getElementById('game-container'),
      engine: engine,
      options: {
        width: 1024,  
        height: 768,
        wireframes: false,
        background: null
      }
    });
 
    Matter.Render.run(render);
    var runner = Runner.create();
    Runner.run(runner, engine);
 
    // Cup setup
    var cupCenterX = 500;
    var cupCenterY = 420;
    var cupWidthTop = 400;
    var cupWidthBottom = 300;
    var cupHeight = 300;
    var cupBottomY = cupCenterY + cupHeight / 2;
       
    var level = 1;
    var coins = 0;  // track coins
    var seeds = 20; // track seeds (currency); starts at 20

    // Cup bodies
    var bottom = Bodies.rectangle(cupCenterX, cupCenterY + cupHeight / 2, cupWidthBottom, 40, {
      isStatic: true,
      render: { fillStyle: '#555' }
    });
 
    var angle = Math.atan((cupWidthTop - cupWidthBottom) / (2 * cupHeight));
 
    var leftWall = Bodies.rectangle(
      cupCenterX - cupWidthBottom / 2 - 20,
      cupCenterY,
      cupHeight,
      40,
      {
        isStatic: true,
        angle: -Math.PI / 2 - angle,
        render: { fillStyle: '#555' }
      }
    );
 
    var rightWall = Bodies.rectangle(
      cupCenterX + cupWidthBottom / 2 + 20,
      cupCenterY,
      cupHeight,
      40,
      {
        isStatic: true,
        angle: Math.PI / 2 + angle,
        render: { fillStyle: '#555' }
      }
    );
 
    Composite.add(world, [bottom, leftWall, rightWall]);
 
    var guideLine = { x: 500, y: 200 };
 
    // 4-level fruit hierarchy
    var fruitHierarchy = {
      'Strawberry': {
        levels: [
          { color: '#c08459', radius: 25, texture: 'strawberry_open1.png' },
          { color: '#a66a3f', radius: 30, texture: 'strawberry_open1.png' },
          { color: '#8e5b36', radius: 40, texture: 'strawberry_open1.png' },
          { color: '#6f472a', radius: 50 , texture: 'strawberry_open1.png' }
        ]
      },
      'Kiwi': {
        levels: [
          { color: '#c08459', radius: 25, texture: 'kiwi_open1.png' },
          { color: '#a66a3f', radius: 30, texture: 'kiwi_open1.png' },
          { color: '#8e5b36', radius: 40, texture: 'kiwi_open1.png' },
          { color: '#6f472a', radius: 50, texture: 'kiwi_open1.png' }
        ]
      },
      'Blueberry': {
        levels: [
          { color: '#c08459', radius: 25, texture: 'blueberry_open1.png' },
          { color: '#a66a3f', radius: 30, texture: 'blueberry_open1.png' },
          { color: '#8e5b36', radius: 40, texture: 'blueberry_open1.png' },
          { color: '#6f472a', radius: 50, texture: 'blueberry_open1.png' }
        ]
      },  
      'Watermelon': {
        levels: [
          { color: '#c08459', radius: 25, texture: 'watermelon_open1.png' },
          { color: '#a66a3f', radius: 30, texture: 'watermelon_open1.png' },
          { color: '#8e5b36', radius: 40, texture: 'watermelon_open1.png' },
          { color: '#6f472a', radius: 50, texture: 'watermelon_open1.png' }
        ]
      },
      'Peach': {
        levels: [
          { color: '#c08459', radius: 25, texture: 'peach_open2.png' },
          { color: '#a66a3f', radius: 30, texture: 'peach_open2.png' },
          { color: '#8e5b36', radius: 40, texture: 'peach_open2.png' },
          { color: '#6f472a', radius: 50, texture: 'peach_open2.png' }
        ]
      },
      'Banana': {
        levels: [
          { color: '#c08459', radius: 25, texture: 'banana_open1.png' },
          { color: '#a66a3f', radius: 30, texture: 'banana_open1.png' },
          { color: '#8e5b36', radius: 40, texture: 'banana_open1.png' },
          { color: '#6f472a', radius: 50, texture: 'banana_open1.png' }
        ]
      }
    };
    var allFruits = Object.keys(fruitHierarchy);

        const textures = {};
    allFruits.forEach(fruit => {
        if (fruitHierarchy[fruit].levels[0].texture) {
            const img = new Image();
            img.src = fruitHierarchy[fruit].levels[0].texture;
            textures[fruit] = img;
            textures["Watermelon_Open"] = new Image();
            textures["Watermelon_Open"].src = "watermelon_open1.png";
            textures["Watermelon_Closed"] = new Image();
            textures["Watermelon_Closed"].src = "watermelon_closed1.png";
            textures["Peach_Open"] = new Image();
            textures["Peach_Open"].src = "peach_open2.png";
            textures["Peach_Closed"] = new Image(); 
            textures["Peach_Closed"].src = "peach_closed2.png";
            textures["Banana_Open"] = new Image();
            textures["Banana_Open"].src = "banana_open1.png";
            textures["Banana_Closed"] = new Image(); 
            textures["Banana_Closed"].src = "banana_closed1.png";
            textures["Blueberry_Open"] = new Image();
            textures["Blueberry_Open"].src = "blueberry_open1.png";
            textures["Blueberry_Closed"] = new Image(); 
            textures["Blueberry_Closed"].src = "blueberry_closed1.png";
            textures["Kiwi_Open"] = new Image();
            textures["Kiwi_Open"].src = "kiwi_open1.png";
            textures["Kiwi_Closed"] = new Image(); 
            textures["Kiwi_Closed"].src = "kiwi_closed1.png";
            textures["Strawberry_Open"] = new Image();
            textures["Strawberry_Open"].src = "strawberry_open1.png";
            textures["Strawberry_Closed"] = new Image(); 
            textures["Strawberry_Closed"].src = "strawberry_closed1.png";
        }
    });

 
    // -------------- CUSTOMERS --------------
    let levelNumber = 1;
    let customers = generateLevel(levelNumber);
 
    function generateLevel(levelNumber) {
      let minCustomers = 1;
      let maxCustomers = Math.min(10, 1 + Math.floor(levelNumber / 5));
      let numCustomers = getRandomInt(minCustomers, maxCustomers);
      let customers = [];
      for (let i=0; i<numCustomers; i++){
        let requests = [];
        let numRequests = getRandomInt(1, 1 + Math.floor(levelNumber/10));
        for (let r=0; r<numRequests; r++){
          let fruitType = allFruits[Math.floor(Math.random()*allFruits.length)];
          let maxFruitLevelIndex = Math.min(3, Math.floor(levelNumber /5));
          let fruitLevel = getRandomInt(1, maxFruitLevelIndex);
          requests.push({
            fruit: fruitType,
            level: fruitLevel,
            quantity: 1
          });
        }
        customers.push({
          id: i+1,
          requests,
          fulfilled: false
        });
      }
 
      // If level=1 => special single Banana L2
      if (levelNumber===1){
        customers=[{
          id:1,
          requests:[{
            fruit:"Banana",
            level:1,
            quantity:1
          }],
          fulfilled:false
        }];
      }
      return customers;
    }
 
    function getRandomInt(min, max){
      return Math.floor(Math.random()* (max-min+1))+min;
    }
 
    function resetCustomers(){
      customers= generateLevel(level);
      Composite.allBodies(world).forEach(body=>{
        if(body.fruitType){
          Composite.remove(world, body);
        }
      });
      console.log("Cup cleared + customers reset for level "+level);
    }
 
    // -------------- CREATE FRUIT (key function) --------------

    // 1) Tweak engine iterations
engine.positionIterations = 10;
engine.velocityIterations = 6;

    function createFruit(x, y, fruitType, level) {
  let type = fruitHierarchy[fruitType];
  let lvlData = type.levels[level];
  let collisionRadius = lvlData.radius * 0.8; // slight inflate for snug collisions
  let fruit = Bodies.circle(x, y, collisionRadius, {
    restitution: 0.5,
    label: fruitType,
    render: {
      visible: false
    }
  });

  fruit.fruitType = fruitType;
  fruit.fruitLevel = level;
  fruit.hierarchyText = (level + 1);

  // If this fruit has both an "Open" and "Closed" texture loaded, let's treat it as "blinking."
  let hasOpenTex = textures[fruitType + "_Open"];
  let hasClosedTex = textures[fruitType + "_Closed"];
  if (hasOpenTex && hasClosedTex) {
    // Assign a per-body blinkData
    fruit.blinkData = {
      state: "Open",         // start as Open
      timer: 0,              // tick counter
      threshold: 80 + Math.floor(Math.random() * 60) 
         // any random timing you like, so each fruit blinks out of sync
    };
  }

  return fruit;
} 
function dropFruit() {
  let curr = currentFruit();
  let fruit = createFruit(guideLine.x, 200, curr.type, curr.level);

  // Give it a slight random spin & horizontal velocity
  Matter.Body.setAngularVelocity(fruit, (Math.random() - 0.5) * 0.2);
  Matter.Body.setVelocity(fruit, { x: (Math.random() - 0.5) * 0.5, y: 0 });

  Composite.add(world, fruit);
  analyzeCup();
  upcomingFruits.shift();
  upcomingFruits.push(getRandomFruitEntry());
}
 
    var upcomingFruits = [
      getRandomFruitEntry(),
      getRandomFruitEntry(),
      getRandomFruitEntry(),
      getRandomFruitEntry(),
      getRandomFruitEntry()
    ];
    function currentFruit(){ return upcomingFruits[0]; }
 
    function getRandomFruitEntry(){
      return {
        type: allFruits[Math.floor(Math.random()*allFruits.length)],
        level: 0
      };
    } 
 
    function analyzeCup(){
      Composite.allBodies(world).forEach((body)=>{
        if(body.fruitType){
          body.highlight=false;
          customers.forEach(customer=>{
            if(!customer.fulfilled){
              customer.requests.forEach(req=>{
                if(!req.fulfilled && req.fruit===body.fruitType && req.level===body.fruitLevel){
                  body.highlight=true;
                }
              });
            }
          });
          // if fruit falls out bottom => loss
          if(body.position.y>1000+ body.circleRadius){
            showLossPopup();
          }
        }
      });
    }
 
    function showLossPopup() {
  if (document.getElementById('popupOverlay')) return;

  var overlay = document.createElement('div');
  overlay.id = 'popupOverlay';
  document.body.appendChild(overlay);

  var popup = document.createElement('div');
  popup.className = 'popupBox';
  popup.innerHTML = `
    <h2>You Lost!</h2>
    </p></p></p></p></p></p></p></p></p></p></p></p></p>
    <p>A fruit fell out of the cup.</p>
    <button id="restartLevelBtn">Restart Level</button>
  `;


  overlay.appendChild(popup);

  var restartLevelButton = document.getElementById('restartLevelBtn');
  if (restartLevelButton) {
    restartLevelButton.addEventListener('click', function () {
      if (overlay) document.body.removeChild(overlay);
      resetLevel();
    });
  }
}
 
    function resetLevel() {
      console.log(`Restarting level ${level}...`);
      resetCustomers();
      Composite.allBodies(world).forEach(body => {
        if (body.fruitType) {
            Composite.remove(world, body);
        }
      });
      console.log("Level restarted and cup cleared.");
    }
 
    function mergeFruits(bodyA, bodyB){
      let fruitType= bodyA.fruitType;
      let level= bodyA.fruitLevel;
      let typeData= fruitHierarchy[fruitType];
      let maxLevel= typeData.levels.length-1;
 
      Composite.remove(world,bodyA);
      Composite.remove(world,bodyB);
 
      if(level===maxLevel){
        coins+=5;
        console.log("5 coins added (max level merge). total:"+ coins);
      }
      if(level<maxLevel){
        let newX= (bodyA.position.x+ bodyB.position.x)/2;
        let newY= (bodyA.position.y+ bodyB.position.y)/2;
        let merged= createFruit(newX,newY, fruitType, level+1);
        Composite.add(world, merged);
      }
    }
 
    Events.on(engine,'collisionStart',(event)=>{
      let pairs= event.pairs;
      pairs.forEach((pair)=>{
        let bodyA= pair.bodyA;
        let bodyB= pair.bodyB;
        if(bodyA.fruitType && bodyB.fruitType){
          if(bodyA.fruitType=== bodyB.fruitType && bodyA.fruitLevel=== bodyB.fruitLevel){
            mergeFruits(bodyA,bodyB);
          }
        }
        if(bodyA.fruitType) checkCustomerRequests(bodyA);
        if(bodyB.fruitType) checkCustomerRequests(bodyB);
      });
    });
 
    function checkCustomerRequests(){
      customers.forEach(customer=>{
        if(!customer.fulfilled){
          const allInCup= customer.requests.every(req=>
            Composite.allBodies(world).some(body=>
              body.fruitType=== req.fruit && body.fruitLevel===req.level
            )
          );
          if(allInCup){
            customer.requests.forEach(req=>{
              // remove them from the cup
              Composite.allBodies(world).forEach(body=>{
                if(body.fruitType===req.fruit && body.fruitLevel===req.level){
                  Composite.remove(world,body);
                }
              });
            });
            customer.fulfilled=true;
          }
        }
      });
      if( customers.every(c=> c.fulfilled)){
        showPopupAndProceed();
      }
    }
 

    function showPopupAndProceed() {
  if (document.getElementById('popupOverlay')) return;
  gamePaused = true;
  coins += 10;
  
    // Log the event to Firebase Analytics
    firebase.analytics().logEvent('level_complete', {
    level_number: level,
    coins_earned: 10
  });

  var overlay = document.createElement('div');
  overlay.id = 'popupOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 999;
  `;
  document.body.appendChild(overlay);

  var popup = document.createElement('div');
  popup.className = 'popupBox';
  popup.innerHTML = `
    <h2>Level Complete!</h2>
    </p>
    </p>
    </p>
    </p>
    </p>
    </p>
    </p>
    </p> </p></p></p></p></p>
    <p>You have earned 10 coins!</p>
    <p>Total Coins: ${coins}</p>
    <button id="nextLevelBtn">Next Level</button>
  `;
  overlay.appendChild(popup);

  var nextLevelButton = document.getElementById('nextLevelBtn');
  if (nextLevelButton) {
    nextLevelButton.addEventListener('click', function () {
      document.body.removeChild(overlay);
      gamePaused = false;
      level++;
      resetCustomers();
    });
  }
}


 
    // Key controls
    var moveLeft=false, moveRight=false, moveSpeed=5;
    var isSpacePressed=false, canDropFruit=true, fruitCooldownTime=300;
 
    document.addEventListener('keydown', function(event){
      if(event.key==='ArrowLeft'){
        moveLeft=true;
      } else if(event.key==='ArrowRight'){
        moveRight=true;
      } else if(event.key===' ' && !isSpacePressed && canDropFruit){
        isSpacePressed=true;
        canDropFruit=false;
        dropFruit();
        setTimeout(()=>{ canDropFruit=true; }, fruitCooldownTime);
      }
    });
    document.addEventListener('keyup', function(event){
      if(event.key==='ArrowLeft') moveLeft=false;
      if(event.key==='ArrowRight') moveRight=false;
      if(event.key===' ') isSpacePressed=false;
    });
 
    // ------------------- Canvas render loop -------------------
    (function renderLoop(){
      updateBlinkStates();
      if(moveLeft && guideLine.x> cupCenterX - (cupWidthTop/2)+20) guideLine.x-= moveSpeed;
      if(moveRight && guideLine.x< cupCenterX + (cupWidthTop/2)-20) guideLine.x+= moveSpeed;
 
      var ctx= render.context;
      ctx.clearRect(0,0, render.canvas.width, render.canvas.height);
      Render.world(render);
 
      drawGuideLine(ctx);
      drawUpcomingFruits(ctx);
      drawCustomers(ctx);
      drawCurrentLevel(ctx);
      displayCoins(ctx);
      displaySeeds(ctx);  // <--- new function to show seeds below coins
 
      drawFruitsWithText(ctx);
      analyzeCup();
 
      requestAnimationFrame(renderLoop);
    })();
 
    function drawGuideLine(ctx) {
    // Draw the guide line
    ctx.beginPath();
    ctx.moveTo(guideLine.x, 240);
    ctx.lineTo(guideLine.x, 400);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Get the current fruit data
    let curr = currentFruit();
    let type = fruitHierarchy[curr.type];
    let lvlData = type.levels[curr.level];

    // Check if the fruit has a texture
    if (lvlData.texture && textures[curr.type]) {
        // Draw the texture if available and loaded
        if (textures[curr.type].complete) {
            ctx.drawImage(
                textures[curr.type],
                guideLine.x - lvlData.radius,
                200 - lvlData.radius,
                lvlData.radius * 2,
                lvlData.radius * 2
            );
        }
    } else {
        // Draw a simple circle if no texture is available
        ctx.beginPath();
        ctx.arc(guideLine.x, 200, lvlData.radius, 0, 2 * Math.PI);
        ctx.fillStyle = lvlData.color;
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.stroke();
    }

    // Draw the fruit level text
    const textColor = getContrastColor(lvlData.color);
    ctx.font = "16px 'Sour Gummy', sans-serif";
    ctx.fillStyle = textColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText((curr.level + 1), guideLine.x, 200);

    // Draw the fruit type text
    ctx.fillStyle = "black";
    ctx.font = "18px 'Sour Gummy', sans-serif";
    ctx.fillText(curr.type, guideLine.x, 230);
}
 
    function drawUpcomingFruits(ctx) {
    let startX = 60;
    let startY = 350;
    let verticalSpacing = 70;

    // Title
    ctx.font = "20px 'Fredoka One', sans-serif";
    ctx.fillStyle = "black";
    ctx.fillText("Upcoming:", startX + 10, startY - 50);

    for (let i = 1; i < upcomingFruits.length; i++) {
        let fruitData = upcomingFruits[i];
        let type = fruitHierarchy[fruitData.type];
        let lvlData = type.levels[fruitData.level];
        let yPos = startY + (i - 1) * verticalSpacing;

        // If a texture is defined and preloaded, draw it
        if (lvlData.texture && textures[fruitData.type]) {
            // OPTIONAL: Check if the image is fully loaded
            if (textures[fruitData.type].complete) {
                ctx.drawImage(
                    textures[fruitData.type],
                    startX - lvlData.radius,
                    yPos - lvlData.radius,
                    lvlData.radius * 2,
                    lvlData.radius * 2
                );

                // Draw fruit-level text on top (optional)
                const textColor = getContrastColor(lvlData.color);
                ctx.font = "16px 'Sour Gummy', sans-serif";
                ctx.fillStyle = textColor;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText((fruitData.level + 1), startX, yPos);
            } 
            // else { // If not complete, optionally do a fallback
            //     // e.g., draw a placeholder circle or do nothing
            // }
        } else {
            // Draw a simple colored circle if no texture or not loaded
            ctx.beginPath();
            ctx.arc(startX, yPos, lvlData.radius, 0, 2 * Math.PI);
            ctx.fillStyle = lvlData.color;
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.stroke();

            const textColor = getContrastColor(lvlData.color);
            ctx.font = "16px 'Sour Gummy', sans-serif";
            ctx.fillStyle = textColor;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText((fruitData.level + 1), startX, yPos);
        }
    }
}

function drawCustomers(ctx) {
    let startX = 250;
    let startY = cupCenterY + cupHeight / 2 - 520;
    let horizontalSpacing = 300;

    // Title
    ctx.font = "20px 'Fredoka One', sans-serif";
    ctx.fillStyle = "black";
    ctx.fillText("Customer Orders:", startX + 30, startY - 30);

    customers.forEach((customer, index) => {
        let xPos = startX + index * horizontalSpacing;
        let yPos = startY;
        ctx.fillStyle = customer.fulfilled ? "green" : "black";
        ctx.fillText(`Customer ${customer.id}`, xPos + 30, yPos);

        let centerX = xPos;
        let centerY = yPos + 40;
        let radius = 30;
        let angleStep = (2 * Math.PI) / customer.requests.length;

        customer.requests.forEach((request, reqIndex) => {
            let type = fruitHierarchy[request.fruit];
            let lvlData = type.levels[request.level];
            let fruitX = centerX + radius * Math.cos(reqIndex * angleStep);
            let fruitY = centerY + radius * Math.sin(reqIndex * angleStep);

            let inCup = Composite.allBodies(world).some(
                (body) => body.fruitType === request.fruit && body.fruitLevel === request.level
            );

            // If a texture exists and is loaded, draw it
            if (lvlData.texture && textures[request.fruit] && textures[request.fruit].complete) {
                ctx.drawImage(
                    textures[request.fruit],
                    fruitX - lvlData.radius,
                    fruitY - lvlData.radius,
                    lvlData.radius * 2,
                    lvlData.radius * 2
                );

                // Highlight fulfilled requests with a border
                if (inCup && !customer.fulfilled) {
                    ctx.beginPath();
                    ctx.arc(fruitX, fruitY, lvlData.radius + 3, 0, 2 * Math.PI);
                    ctx.strokeStyle = "green";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            } else {
                // Fallback: Draw a simple colored circle if no texture exists
                ctx.beginPath();
                ctx.arc(fruitX, fruitY, lvlData.radius, 0, 2 * Math.PI);
                ctx.fillStyle = customer.fulfilled ? "grey" : lvlData.color;
                ctx.fill();
                ctx.strokeStyle = inCup && !customer.fulfilled ? "green" : "black";
                ctx.lineWidth = inCup && !customer.fulfilled ? 3 : 1;
                ctx.stroke();
            }

            // Draw fruit-level text on top
            const textColor = getContrastColor(lvlData.color);
            const effectiveColor = customer.fulfilled ? "#aaaaaa" : lvlData.color;
            const txtFillColor = getContrastColor(effectiveColor);
            ctx.font = "16px 'Sour Gummy', sans-serif";
            ctx.fillStyle = txtFillColor;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(request.level + 1, fruitX, fruitY);
        });
    });
}

function updateBlinkStates() {
  Composite.allBodies(world).forEach(body => {
    // Skip bodies that have no blink data
    if (!body.blinkData) return;

    // Increment that body's timer
    body.blinkData.timer++;

    // When it exceeds threshold, flip the state
    if (body.blinkData.timer >= body.blinkData.threshold) {
      body.blinkData.state = (body.blinkData.state === "Open") ? "Closed" : "Open";
      body.blinkData.timer = 0;
    }
  });
}
    function drawCurrentLevel(ctx){
      ctx.font="40px 'Honk', sans-serif";
      ctx.fillStyle="black";
      ctx.fillText("Level: "+level,80,30);
    }
 
    function displayCoins(ctx){
      ctx.font="40px 'Honk', sans-serif";
      ctx.fillStyle="black";
      ctx.fillText("Coins: "+ coins,82,80);
    }

    // (1) Draw Seeds below coins
    function displaySeeds(ctx){
      ctx.font="40px 'Honk', sans-serif";
      ctx.fillStyle="black";
      // We'll draw it around y=130
      ctx.fillText("Seeds: "+ seeds, 82, 130);
    }

    // Add a click listener to detect clicks on the Seeds area in the canvas
    render.canvas.addEventListener('click', (e) => {
      // get bounding rect for the canvas
      const rect = render.canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      // Rough bounding box for "Seeds" text: x ~ 82..250, y ~ 100..140
      if (clickX >= 82 && clickX <= 250 && clickY >= 100 && clickY <= 140) {
        openSeedsPurchasePopup();
      }
    });

    // (2) Open a popup that allows user to buy seeds
    function openSeedsPurchasePopup(){
      // If a popup is already open, do nothing
      if(document.getElementById('popupOverlay')) return;

      let overlay = document.createElement('div');
      overlay.id = 'popupOverlay';
      document.body.appendChild(overlay);

      let popup = document.createElement('div');
      popup.className = 'popupBox';
      popup.innerHTML = `
        <h2>Buy Seeds</h2>
        </p>
        <p>Each seed costs 10 coins. You have ${coins} coins.</p>
        <p>Max seeds you can afford: ${Math.floor(coins/10)}</p>
        <input type="range" id="seedRange" min="0" max="${Math.floor(coins/10)}" value="0" />
        <span id="seedRangeValue">0</span>
      
        <button id="purchaseSeedsBtn">Purchase</button>
        <button id="closePopupBtn">Cancel</button>
      `;
      overlay.appendChild(popup);

      // Range input listener
      let rangeEl = document.getElementById('seedRange');
      let rangeValueEl = document.getElementById('seedRangeValue');
      rangeEl.addEventListener('input', () => {
        rangeValueEl.textContent = rangeEl.value;
      });

      // Purchase button
      let purchaseBtn = document.getElementById('purchaseSeedsBtn');
      purchaseBtn.addEventListener('click', () => {
        let amountToBuy = parseInt(rangeEl.value);
        if (amountToBuy > 0) {
          let cost = amountToBuy * 10;
          coins -= cost;
          seeds += amountToBuy;
        }
        document.body.removeChild(overlay);
      });

      // Close/cancel button
      let closeBtn = document.getElementById('closePopupBtn');
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
    }
 
    function drawFruitsWithText(ctx) {
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      const posX = body.position.x;
      const posY = body.position.y;
      const angle = body.angle;
      const radius = fruitHierarchy[body.fruitType].levels[body.fruitLevel].radius;
      const bgColor = fruitHierarchy[body.fruitType].levels[body.fruitLevel].color;

      // Highlight ring
      if (body.highlight) {
        ctx.beginPath();
        ctx.arc(posX, posY, radius + 3, 0, 2 * Math.PI);
        ctx.strokeStyle = "green";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Canvas transform to rotate with physics
      ctx.save();
      ctx.translate(posX, posY);
      ctx.rotate(angle);

      if (body.blinkData) {
        // If this body is blinking
        const blinkState = body.blinkData.state; // "Open" or "Closed"
        const texKey = body.fruitType + "_" + blinkState;
        const texture = textures[texKey];

        if (texture && texture.complete) {
          ctx.drawImage(texture, -radius, -radius, radius * 2, radius * 2);
        } else {
          // fallback circle
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, 2 * Math.PI);
          ctx.fillStyle = bgColor;
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        }

      } else {
        // Non-blinking or fruit with no blinkData
        let defaultTexture = fruitHierarchy[body.fruitType].levels[body.fruitLevel].texture;
        if (defaultTexture && textures[body.fruitType] && textures[body.fruitType].complete) {
          ctx.drawImage(textures[body.fruitType], -radius, -radius, radius * 2, radius * 2);
        } else {
          // Fallback circle
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, 2 * Math.PI);
          ctx.fillStyle = bgColor;
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        }
      }

      ctx.restore(); // reset transforms

      // Fruit-level text (non-rotated)
      const textColor = getContrastColor(bgColor);
      ctx.font = "16px 'Sour Gummy', sans-serif";
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(body.hierarchyText, posX, posY);
    }
  });
}
    function getContrastColor(hexColor){
      // handle short color or no '#'
      if(hexColor[0] === '#') hexColor = hexColor.slice(1);
      if(hexColor.length < 6) {
        // for simplicity, just return black
        return "black";
      }
      let r= parseInt(hexColor.slice(0,2),16);
      let g= parseInt(hexColor.slice(2,4),16);
      let b= parseInt(hexColor.slice(4,6),16);
      let luminance= 0.2126*(r/255)+ 0.7152*(g/255)+ 0.0722*(b/255);
      return luminance>0.5? "black": "white";
    }
 
    /**************************************************************
     * 3) PACHINKO CODE
     **************************************************************/
    const pachinkoCanvas = document.getElementById("pachinkoCanvas");
    const pCtx = pachinkoCanvas.getContext("2d");
 
    let pWidth = pachinkoCanvas.clientWidth;
    let pHeight= pachinkoCanvas.clientHeight;
    pachinkoCanvas.width= pWidth;
    pachinkoCanvas.height= pHeight;
 
    let pachinkoFieldHeight= 300;
    let gardenHeight= pHeight - pachinkoFieldHeight;

    // We REMOVE ballCount=20; we use the global seeds variable instead
    // We'll rename the old "seeds" object that stored Mango/Pineapple/Lichi to basketProgress
    const basketProgress = { Mango:0, Pineapple:0, Lichi:0 };
    let gardenFruits= { Mango:false, Pineapple:false, Lichi:false };

    const balls= [];
    const pegs= [];
 
    let baskets=[
      { x:0,y: pachinkoFieldHeight-20, w:60,h:20, type:"Mango"     },
      { x:60,y:pachinkoFieldHeight-20, w:60,h:20, type:"Pineapple" },
      { x:120,y:pachinkoFieldHeight-20, w:60,h:20, type:"Lichi"    },
      { x:180,y:pachinkoFieldHeight-20, w:60,h:20, type:null       }
    ];
    let basketSpeed= 1.5;
    let basketDirection=1;
 
    const ballRadius2= 8;
    const pegRadius2= 4;
    const gravity2= 0.3;
    const damping2= 0.8;
    const friction2= 0.98;
 
    let dropX= pWidth/2;
    let dropSpeed2=2;
    let dropDir2= 1;
 
    function createPegs2(){
      pegs.length=0;
      let spacingX=40;
      let spacingY=40;
      let offsetX=20;
      let offsetY=40;
      let cols= Math.floor((pWidth-offsetX)/ spacingX);
      let rows= Math.floor((pachinkoFieldHeight - offsetY)/ spacingY)-1;
      for(let r=0; r<rows; r++){
        for(let c=0; c<cols; c++){
          let px= offsetX + c*spacingX + (r%2 ? spacingX/2:0);
          let py= offsetY + r*spacingY;
          pegs.push({x:px,y:py});
        }
      }
    }
 
    function initPachinko(){
      createPegs2();
      let totalW= baskets.length*60;
      let startX= (pWidth - totalW)/2;
      baskets.forEach((bk,i)=>{
        bk.x= startX + i*60;
        bk.y= pachinkoFieldHeight- bk.h;
      });
      dropX= pWidth/2;
    }
    initPachinko();
 
    function pachinkoLoop(){
      updatePachinko();
      drawPachinko();
      requestAnimationFrame(pachinkoLoop);
    }
    pachinkoLoop();
 
    function updatePachinko(){
      dropX+= dropSpeed2*dropDir2;
      if(dropX<15){ dropX=15; dropDir2=1;}
      if(dropX> pWidth-15){ dropX= pWidth-15; dropDir2=-1;}
 
      baskets.forEach(b=> b.x+= basketSpeed* basketDirection);
      let leftB= baskets[0].x;
      let rightB= baskets[baskets.length-1].x+ baskets[baskets.length-1].w;
      if(leftB<0){
        let shift= -leftB;
        baskets.forEach(b=> b.x+=shift);
        basketDirection=1;
      } else if(rightB> pWidth){
        let shift= pWidth- rightB;
        baskets.forEach(b=> b.x+= shift);
        basketDirection=-1;
      }
 
      for(let i= balls.length-1; i>=0; i--){
        let ball= balls[i];
        ball.vy+= gravity2;
        ball.vx*= friction2;
        ball.x+= ball.vx;
        ball.y+= ball.vy;
 
        // Peg collisions
        for(let peg of pegs){
          let dx= ball.x- peg.x;
          let dy= ball.y- peg.y;
          let dist= Math.sqrt(dx*dx + dy*dy);
          if(dist< ballRadius2+ pegRadius2){
            let angle= Math.atan2(dy,dx);
            let overlap= (ballRadius2+ pegRadius2)-dist;
            ball.x+= Math.cos(angle)*overlap;
            ball.y+= Math.sin(angle)*overlap;
 
            let nx= dx/dist;
            let ny= dy/dist;
            let proj= ball.vx*nx + ball.vy*ny;
            ball.vx-= 2*proj*nx;
            ball.vy-= 2*proj*ny;
            ball.vx*= damping2;
            ball.vy*= damping2;
          }
        }
 
        // Left/Right walls
        if(ball.x< ballRadius2){
          ball.x= ballRadius2;
          ball.vx=-ball.vx*damping2;
        }
        if(ball.x> pWidth- ballRadius2){
          ball.x= pWidth- ballRadius2;
          ball.vx=-ball.vx*damping2;
        }
 
        // Reached bottom (baskets)
        if(ball.y> pachinkoFieldHeight- ballRadius2){
          for(let bk of baskets){
            if(ball.x> bk.x && ball.x< bk.x+ bk.w){
              // if basket has a fruit type, increment progress
              if(bk.type && gardenFruits[bk.type]=== false){
                basketProgress[bk.type]++;
                // If we get 5 seeds in that basket, "grow" the fruit
                if(basketProgress[bk.type]>=5){
                  gardenFruits[bk.type]= true;
                }
              }
              break;
            }
          }
          balls.splice(i,1);
        }
      }
    }
 
    function drawPachinko(){
      pCtx.clearRect(0,0,pWidth,pHeight);
 
      // Draw pegs
      pCtx.fillStyle='#888';
      for(let peg of pegs){
        pCtx.beginPath();
        pCtx.arc(peg.x, peg.y, pegRadius2,0,2*Math.PI);
        pCtx.fill();
      }
 
      // Draw baskets
      for(let bk of baskets){
        if(!bk.type) pCtx.fillStyle='#444';
        else if(bk.type==='Mango') pCtx.fillStyle='#ffaa00';
        else if(bk.type==='Pineapple') pCtx.fillStyle='#ccff55';
        else if(bk.type==='Lichi') pCtx.fillStyle='#ff66aa';
        pCtx.fillRect(bk.x,bk.y,bk.w,bk.h);
 
        pCtx.fillStyle='#000';
        pCtx.font="14px 'Sour Gummy', sans-serif";
        pCtx.textAlign='center';
        pCtx.textBaseline='middle';
        let label= bk.type? bk.type:"None";
        pCtx.fillText(label, bk.x+ bk.w/2, bk.y+ bk.h/2);
      }
 
      // Draw the balls
      pCtx.fillStyle='#0e9c65';
      for(let b of balls){
        pCtx.beginPath();
        pCtx.arc(b.x,b.y, ballRadius2,0,2*Math.PI);
        pCtx.fill();
      }
 
      // Drop indicator
      pCtx.strokeStyle='#0f0';
      pCtx.beginPath();
      pCtx.moveTo(dropX,0);
      pCtx.lineTo(dropX,30);
      pCtx.stroke();
      pCtx.beginPath();
      pCtx.arc(dropX,30,5,0,2*Math.PI);
      pCtx.fillStyle='#0f0';
      pCtx.fill();
 
      drawGarden();
 
      // Show how many seeds remain (instead of old ballCount)
      pCtx.fillStyle='#000';
      pCtx.font="16px 'Sour Gummy', sans-serif";
      pCtx.fillText(`Seeds left: ${seeds}`, 10, 20);
    }
 
    function drawGarden(){
      pCtx.fillStyle='#A7C957';
      pCtx.fillRect(0, pachinkoFieldHeight, pWidth, gardenHeight);
 
      let lanes={
        Mango:{ xStart:20, yCenter: pachinkoFieldHeight+30, color:'#ffaa00'},
        Pineapple:{ xStart:20, yCenter: pachinkoFieldHeight+60, color:'#ccff55'},
        Lichi:{ xStart:20, yCenter: pachinkoFieldHeight+90, color:'#ff66aa'}
      };
 
      Object.keys(basketProgress).forEach(fruit=>{
        let lane= lanes[fruit];
        let seedCount= basketProgress[fruit];
        // If the fruit is fully grown
        if(gardenFruits[fruit]){
          pCtx.beginPath();
          pCtx.arc(pWidth-40, lane.yCenter,20,0,2*Math.PI);
          pCtx.fillStyle= lane.color;
          pCtx.fill();
          pCtx.fillStyle='#000';
          pCtx.font="14px 'Sour Gummy', sans-serif";
          pCtx.textAlign='center';
          pCtx.textBaseline='middle';
          pCtx.fillText(fruit, pWidth-40, lane.yCenter);
        } else {
          // Just draw seeds collected so far
          let radius=6;
          let spacing=20;
          for(let i=0; i< seedCount; i++){
            let seedX= lane.xStart + i*(radius*2+ spacing);
            pCtx.beginPath();
            pCtx.arc(seedX, lane.yCenter, radius,0,2*Math.PI);
            pCtx.fillStyle= lane.color;
            pCtx.fill();
          }
          pCtx.fillStyle='#000';
          pCtx.font="14px 'Sour Gummy', sans-serif";
          pCtx.textAlign='left';
          pCtx.textBaseline='middle';
          pCtx.fillText(fruit, 5, lane.yCenter);
        }
      });
    }
 
    // Use seeds (currency) to drop pachinko balls
    pachinkoCanvas.addEventListener('click', ()=>{
      if(seeds>0){
        seeds--;
        balls.push({
          x: dropX,
          y: 30,
          vx: (Math.random()-0.5)*3,
          vy: 0
        });
      }
    });
  </script>
</body>
</html>
