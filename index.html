<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=1024, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Fruit Merge Game + Pachinko</title>
 
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Sour+Gummy&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Honk&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">

 
  <!-- Matter.js (for the main Fruit Merge game) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.21.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.21.0/firebase-analytics-compat.js"></script>
 
  <style>
#barn-cover {
  position: absolute;
  top: -100px; /* Align to the top of the Pachinko container */
  left: -100px; /* Align to the left of the Pachinko container */
  width: 200px; /* Cover the entire Pachinko canvas */
  height: 200px; /* Match the Pachinko canvas height */
  display: block; /* Hide with JavaScript when necessary */
  background: none; /* Optional semi-transparent background */
  z-index: 1; /* Ensure it stays above Pachinko elements */
  transition: opacity 1s ease-out; /* Smooth fade-out transition */
  opacity: 1; /* Fully visible initially */
}

#barn-image {
  width: 250%; /* Ensure the image scales to fit */
  height: auto; /* Maintain aspect ratio */
}

    body {
      margin: 0;
      padding: 0;
      background-color: #000; /* Optional fallback */
      overflow: hidden;       /* Disable scrolling */
      width: 1300px;         /* Fixed layout width */
      height: 768px;         /* Fixed layout height */
    }
 
    /* Fixed background layer */
    #background-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 1300px;
      height: 731px;
      background-image: url('https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/background8%20(2).jpg');;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      z-index: -1; /* Keep behind everything else */
    }
 
    /* Main game container is also fixed to avoid movement */
    #game-container {
      position: fixed;        /* Pin to the top-left to match the background */
      top: 0;
      left: 0;
      width: 1024px;
      height: 768px;
      overflow: hidden;
      transform: scale(0.9); /* Scale down to 90% */
      transform-origin: top left;
    }
 
    canvas {
      display: block;
      width: 1024px;  /* Fixed canvas width */
      height: 768px; /* Fixed canvas height */
    }
 
    .pachinko-container {
      position: absolute;
      top: 282px; /* Adjust as needed */
      left: 800px;
      width: 320px;
      height: 600px;
      pointer-events: none;  /* Let clicks pass through (if desired) */
    }
 
    #pachinkoCanvas {
      width: 320px;
      height: 430px;
      background: transparent;
      pointer-events: auto;  /* Re-enable clicks on this canvas */
      /* border: 2px solid rgba(255,255,255,0.2); */
    }

    .popupBox {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: url('https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/Banner.png') no-repeat center center; /* Use the banner as the background */
  background-size: contain; /* Ensure the image scales properly */
  width: 600px; /* Adjust width to match banner */
  height: 403px; /* Adjust height to match banner */
  display: flex;
  flex-direction: column ;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 20px;
  z-index: 10000;
  box-sizing: border-box;
  font-family: 'Fredoka One', sans-serif; /* Consistent font styling */
  color: black; /* Text color for better readability */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add a subtle shadow */
}

.popupBox h2 {
  font-size: 26px; 
  margin: 0 0 10px;
}

.popupBox p {
  font-size: 18px;
  margin: 5px 0;
}

.popupBox button {
  font-size: 18px;
  font-family: 'Honk', sans-serif;
  padding: 10px 20px;
  background-color: #f0c040; /* Button background color */
  color: black; /* Button text color */
  border: none;
  border-radius: 5px;
  margin-top: 15px;
  cursor: pointer;
  transition: background-color 0.2s;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.popupBox button:hover {
  background-color: #e0b030; /* Slightly darker color on hover */
}

#muteButton {
  position: absolute;
  top: 20px; /* Adjust for spacing */
  right: 5%; /* Adjust for spacing */
  z-index: 10000; /* Ensure it's above other elements */
  background: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
  color: white; /* Button text color */
  border: none;
  padding: 10px 15px;
  font-size: 20px;
  border-radius: 50%; /* Make it circular */
  cursor: pointer;
  transition: background-color 0.2s ease;
}

#muteButton:hover {
  background: rgba(0, 0, 0, 0.7);
}


  </style>
</head>
 
<body>

  <div id="loading-screen" style="position: fixed; width: 100%; height: 100%; background: black; color: white; display: flex; align-items: center; justify-content: center; font-size: 24px; z-index: 9999;">
    Loading...
  </div>

    <!-- Audio for Background Music -->
    <audio id="backgroundMusic" loop>
      <source src="background_music.mp3" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>

    <audio id="mergeSound">
      <source src="merge1.wav" type="audio/wav">
      Your browser does not support the audio element.
    </audio>
 
    <audio id="orderFulfilledSound">
      <source src="Order_fulfilled.mp3" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
    
    <audio id="cartoonSlurpSound">
      <source src="Cartoon_Slurp.mp3" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
    
    <audio id="rootEvolveSound">
      <source src="root_evolve.mp3" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>

      <!-- Mute Button -->
  <button id="muteButton">🔊</button>

  <div id="background-layer"></div>
  <div id="game-container"></div>
 
  <!-- Pachinko container & canvas -->
  <div class="pachinko-container">
    <!-- Barn Cover for Pachinko -->
<div id="barn-cover">
  <img src="./barn.png" alt="Barn Cover" id="barn-image">
</div>

    <canvas id="pachinkoCanvas"></canvas>
  </div>

  <!-- near the bottom of <body>... -->
<div id="frenzyOverlay" style="
position: fixed;
top:0; left:0;
width:100%; height:100%;
background: rgba(0,0,0,0.5);
z-index:9999;
text-align:center;
display:none;
color:white;
font-family: 'Fredoka One', sans-serif;
font-size: 36px;
padding-top: 200px;
">
<h1>FRUIT FRENZY!</h1>
<p>Merge as many fruits as you can in 10 seconds!</p>
</div>
 
  <script>
    

  // Preloader Function
  function preloadAssets(assetUrls, onComplete) {
    let loadedCount = 0;
    const totalAssets = assetUrls.length;
    const loadedAssets = {};

    assetUrls.forEach((url) => {
      const img = new Image();
      img.src = url;
      img.onload = () => {
        loadedCount++;
        loadedAssets[url] = img;
        if (loadedCount === totalAssets) {
          onComplete(loadedAssets);
        }
      };
      img.onerror = () => {
        console.error(`Failed to load asset: ${url}`);
      };
    });
  }

  function initializeGame(loadedAssets) {
    document.getElementById('loading-screen').style.display = 'none';
    allFruits.forEach((fruit) => {
      if (fruitHierarchy[fruit].levels[0].texture) {
        textures[fruit] = loadedAssets[fruitHierarchy[fruit].levels[0].texture];
      }
    });

    textures["Watermelon_Open"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_open1.png'];
    textures["Watermelon_Closed"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_closed1.png'];
    textures["Peach_Open"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_open2.png'];
    textures["Peach_Closed"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_closed2.png'];
    textures["Banana_Open"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_open1.png'];
    textures["Banana_Closed"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_closed1.png'];
    textures["Blueberry_Open"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_open1.png'];
    textures["Blueberry_Closed"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_closed1.png'];
    textures["Kiwi_Open"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_open1.png'];
    textures["Kiwi_Closed"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_closed1.png'];
    textures["Strawberry_Open"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_open1.png'];
    textures["Strawberry_Closed"] = loadedAssets['https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_closed1.png'];
    // Example of mapping root images to the textures object AFTER they’re loaded:
textures["root1"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root1.png"];
textures["root2"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root2.png"];
textures["root3"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root3.png"];
textures["root4"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root4.png"];

textures["root_mango"]      = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root_mango.png"];
textures["root_pineapple"]  = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root_pineapple.png"];
textures["root_lychee"]     = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root_lychee.png"];

textures["Mango_Open"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/mango_open.png"];
textures["Mango_Closed"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/mango_closed.png"];

textures["Pineapple_Open"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/pineapple_open.png"];
textures["Pineapple_Closed"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/pineapple_closed.png"];

textures["Lychee_Open"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/lychee_open.png"];
textures["Lychee_Closed"] = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/lychee_closed.png"];

textures["blob_green1"]   = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_green1.png"];
  textures["blob_orange1"]  = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_orange1.png"];
  textures["blob_pink1"]    = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_pink1.png"];
  textures["blob_purple1"]  = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_purple1.png"];
  textures["blob_red1"]     = loadedAssets["https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_red1.png"];

    // Start the game loop or initialization
    startGame();
  }

  
    // Play background music when the page is loaded
    window.addEventListener('load', () => {
      const music = document.getElementById('backgroundMusic');
      music.volume = 0.02; // Set initial volume to 50%
      music.play().catch(err => {
        console.warn("Autoplay was prevented:", err);
      });
      // Optional: Add a click to enable autoplay if necessary
      document.body.addEventListener('click', () => {
        if (music.paused) {
          music.play();
        }
      }, { once: true });
    });

    // Background Music
const backgroundMusic = document.getElementById('backgroundMusic');
const muteButton = document.getElementById('muteButton');

// Automatically start playing the music when the page loads
backgroundMusic.volume = 0.5; // Adjust volume as needed
backgroundMusic.play();

// Toggle mute/unmute
muteButton.addEventListener('click', () => {
  if (backgroundMusic.muted) {
    backgroundMusic.muted = false;
    muteButton.textContent = '🔊'; // Update button icon
  } else {
    backgroundMusic.muted = true;
    muteButton.textContent = '🔇'; // Update button icon
  }
});

  // Collect Asset URLs
  const assetUrls = [
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_open1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_open1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_open1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_open1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_open2.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_open1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_closed1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_closed2.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_closed1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_closed1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_closed1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_closed1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/background8%20(2).jpg',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/Banner.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root1.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root2.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root3.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root4.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root_mango.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root_pineapple.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/root_lychee.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/mango_open.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/pineapple_open.png',
    'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/lychee_open.png',
    "https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_green1.png",
    "https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_orange1.png",
    "https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_pink1.png",
    "https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_purple1.png",
    "https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blob_red1.png", 


  ];

    /**************************************************************
     * 1) Firebase Initialization
     **************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyC1UkIoa4YLssMC0sQDAqFmqneIJ7PpCsU",
      authDomain: "fruit-merge-idc-game.firebaseapp.com",
      projectId: "fruit-merge-idc-game",
      storageBucket: "fruit-merge-idc-game.firebasestorage.app",
      messagingSenderId: "581122347526",
      appId: "1:581122347526:web:7d120f38a40c60a7c2e987",
      measurementId: "G-VDD7CG94Y2"
    };

    
    firebase.initializeApp(firebaseConfig);
    if (firebase.apps.length === 0) {
  console.error("Firebase initialization failed.");
} else {
  console.log("Firebase initialized successfully.");
}
    firebase.analytics();
 
    /**************************************************************
     * 2) Main Fruit Merge Game with Matter.js
     **************************************************************/
    var Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Composite = Matter.Composite,
        Bodies = Matter.Bodies,
        Events = Matter.Events;
 

  // Preload Assets
  preloadAssets(assetUrls, (loadedAssets) => {
    console.log('All assets loaded successfully!');
    initializeGame(loadedAssets);
  });

  // Define the game engine and render settings
  var Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Composite = Matter.Composite,
      Bodies = Matter.Bodies,
      Events = Matter.Events;

  var engine = Engine.create(),
      world = engine.world;

    var engine = Engine.create(),
        world = engine.world;
 
    var render = Matter.Render.create({
      element: document.getElementById('game-container'),
      engine: engine,
      options: {
        width: 1024,  
        height: 768,
        wireframes: false,
        background: null
      }
    });
 
    Matter.Render.run(render);
    var runner = Runner.create();
    Runner.run(runner, engine);
 
    // Cup setup
    var cupCenterX = 500;
    var cupCenterY = 500;
    var cupWidthTop = 400;
    var cupWidthBottom = 300;
    var cupHeight = 300;
    var cupBottomY = cupCenterY + cupHeight / 2;
       
    var level = 1; // Level initialization

    // Function to toggle the barn cover visibility
    function toggleBarnCover(show) {
      const barnCover = document.getElementById("barn-cover");
      barnCover.style.display = show ? "block" : "none";
    }

    // Set initial barn visibility based on the starting level
    if (level > 5) {
      toggleBarnCover(false); // Show Pachinko
    } else {
      toggleBarnCover(true); // Keep Barn covering
    }

    var coins = 0;  // track coins
    var seeds = 1000; // track seeds (currency); starts at 20



    // Cup bodies
    var bottom = Bodies.rectangle(cupCenterX, cupCenterY + cupHeight / 2, cupWidthBottom, 40, {
      isStatic: true,
      render: { fillStyle: '#555' }
    });
 
    var angle = Math.atan((cupWidthTop - cupWidthBottom) / (2 * cupHeight));
 
    var leftWall = Bodies.rectangle(
      cupCenterX - cupWidthBottom / 2 - 20,
      cupCenterY,
      cupHeight,
      40,
      {
        isStatic: true,
        angle: -Math.PI / 2 - angle,
        render: { fillStyle: '#555' }
      }
    );
 
    var rightWall = Bodies.rectangle(
      cupCenterX + cupWidthBottom / 2 + 20,
      cupCenterY,
      cupHeight,
      40,
      {
        isStatic: true,
        angle: Math.PI / 2 + angle,
        render: { fillStyle: '#555' }
      }
    );
 
    Composite.add(world, [bottom, leftWall, rightWall]);
 
    var guideLine = { x: 500, y: 300 };
 
    // 4-level fruit hierarchy
    var fruitHierarchy = {
      'Strawberry': {
        levels: [
          { color: '#c08459', radius: 25, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_open1.png' },
          { color: '#a66a3f', radius: 35, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_open1.png' },
          { color: '#8e5b36', radius: 45, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_open1.png' },
          { color: '#6f472a', radius: 55 , texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_open1.png' }
        ]
      },
      'Kiwi': {
        levels: [
          { color: '#c08459', radius: 30, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_open1.png' },
          { color: '#a66a3f', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_open1.png' },
          { color: '#8e5b36', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_open1.png' },
          { color: '#6f472a', radius: 60, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_open1.png' }
        ]
      },
      'Blueberry': {
        levels: [
          { color: '#c08459', radius: 20, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_open1.png' },
          { color: '#a66a3f', radius: 30, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_open1.png' },
          { color: '#8e5b36', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_open1.png' },
          { color: '#6f472a', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_open1.png' }
        ]
      },  
      'Watermelon': {
        levels: [
          { color: '#c08459', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_open1.png' },
          { color: '#a66a3f', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_open1.png' },
          { color: '#8e5b36', radius: 60, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_open1.png' },
          { color: '#6f472a', radius: 70, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_open1.png' }
        ]
      },
      'Peach': {
        levels: [
          { color: '#c08459', radius: 30, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_open2.png' },
          { color: '#a66a3f', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_open2.png' },
          { color: '#8e5b36', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_open2.png' },
          { color: '#6f472a', radius: 60, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_open2.png' }
        ]
      },
      'Banana': {
        levels: [
          { color: '#c08459', radius: 30, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_open1.png' },
          { color: '#a66a3f', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_open1.png' },
          { color: '#8e5b36', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_open1.png' },
          { color: '#6f472a', radius: 60, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_open1.png' }
        ]
      },
      'Mango': {
        levels: [
          { color: '#ffaa00', radius: 30, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/mango_open.png'},
          { color: '#ffaa00', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/mango_open.png' },
          { color: '#ffaa00', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/mango_open.png' },
          { color: '#ffaa00', radius: 60, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/mango_open.png' }
        ]
      },
      'Pineapple': {
        levels: [
          { color: '#ccff55', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/pineapple_open.png' },
          { color: '#ccff55', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/pineapple_open.png' },
          { color: '#ccff55', radius: 60, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/pineapple_open.png' },
          { color: '#ccff55', radius: 70, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/pineapple_open.png' }
        ]
      },
      'Lychee': {
        levels: [
          { color: '#ff66aa', radius: 20, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/lychee_open.png' },
          { color: '#ff66aa', radius: 30, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/lychee_open.png' },
          { color: '#ff66aa', radius: 40, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/lychee_open.png' },
          { color: '#ff66aa', radius: 50, texture: 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/lychee_open.png' }
        ]
      }

    };
    var allFruits = Object.keys(fruitHierarchy);

        const textures = {};
    allFruits.forEach(fruit => {
        if (fruitHierarchy[fruit].levels[0].texture) {
            const img = new Image();
            img.src = fruitHierarchy[fruit].levels[0].texture;
            textures[fruit] = img;
            textures["Watermelon_Open"] = new Image();
            textures["Watermelon_Open"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_open1.png';
            textures["Watermelon_Closed"] = new Image();
            textures["Watermelon_Closed"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/watermelon_closed1.png';
            textures["Peach_Open"] = new Image();
            textures["Peach_Open"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_open2.png';
            textures["Peach_Closed"] = new Image(); 
            textures["Peach_Closed"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/peach_closed2.png';
            textures["Banana_Open"] = new Image();
            textures["Banana_Open"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_open1.png';
            textures["Banana_Closed"] = new Image(); 
            textures["Banana_Closed"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/banana_closed1.png';
            textures["Blueberry_Open"] = new Image();
            textures["Blueberry_Open"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_open1.png';
            textures["Blueberry_Closed"] = new Image(); 
            textures["Blueberry_Closed"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/blueberry_closed1.png';
            textures["Kiwi_Open"] = new Image();
            textures["Kiwi_Open"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_open1.png';
            textures["Kiwi_Closed"] = new Image(); 
            textures["Kiwi_Closed"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/kiwi_closed1.png';
            textures["Strawberry_Open"] = new Image();
            textures["Strawberry_Open"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_open1.png';
            textures["Strawberry_Closed"] = new Image(); 
            textures["Strawberry_Closed"].src = 'https://raw.githubusercontent.com/shekelrey/Fruit-Merge/main/strawberry_closed1.png';
        }
    });

    const standardFruits = ["Strawberry","Kiwi","Blueberry","Watermelon","Peach","Banana"];
    const specialFruits = ["Mango","Pineapple","Lychee"];
    // const allFruits = standardFruits.concat(specialFruits);
 
    const lanes = {
  Mango:     { xStart: 20,  yStart: 330, width: 90, height: 90 },
  Pineapple: { xStart: 130, yStart: 330, width: 90, height: 90 },
  Lychee:    { xStart: 250, yStart: 330, width: 90, height: 90 }
};
    // -------------- CUSTOMERS --------------
    let levelNumber = 1;
    let customers = generateLevel(levelNumber);
    let storedCustomers = {}; // Object to store customer requests for each level


    function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Predefine a list of possible blob filenames (the keys you used above)
const availableBlobs = [
  "blob_green1",
  "blob_orange1",
  "blob_pink1",
  "blob_purple1",
  "blob_red1",
];

function generateLevel(levelNumber) {
  let minCustomers = Math.min(3, 1 + Math.floor(levelNumber / 3));
  let maxCustomers = Math.min(10, 3 + Math.floor(levelNumber / 2));
  let numCustomers = getRandomInt(minCustomers, maxCustomers);

  let customers = [];
  for (let i = 0; i < numCustomers; i++) {
    let requests = [];
    let numRequests = Math.min(5, 1 + Math.floor(levelNumber / 5));
    for (let r = 0; r < numRequests; r++) {
      let fruitType = allFruits[Math.floor(Math.random() * allFruits.length)];
      let maxFruitLevelIndex = Math.min(3, Math.floor(levelNumber / 3));
      let fruitLevel = getRandomInt(1, maxFruitLevelIndex);
      let quantity = getRandomInt(1, Math.min(3, 1 + Math.floor(levelNumber / 5)));

      requests.push({
        fruit: fruitType,
        level: fruitLevel,
        quantity: quantity,
      });
    }
    customers.push({
      id: i + 1,
      requests,
      fulfilled: false,
    });
  }

  // Special case for level 1
  if (levelNumber === 1) {
    customers = [
      {
        id: 1,
        requests: [
          {
            fruit: "Banana",
            level: 1,
            quantity: 1,
          },
        ],
        fulfilled: false,
      },
    ];
  }

  return customers;
}

    /***********************************************************
     * 0) GLOBAL FRENZY VARIABLES
     ***********************************************************/
     let frenzyActive      = false;
    let frenzyFruitType   = null;
    let autoSpawnInterval = null; // for setInterval handle
    let frenzyPhaseTimeout = null; // handle for setTimeouts

    // Clears the cup and sets customers = [] so there's nothing on screen
function clearCupAndCustomers() {
  // Remove all fruit bodies
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      Composite.remove(world, body);
    }
  });
  // Clear out any existing customers
  customers = [];
}

/***********************************************************
 * 2) FRUIT FRENZY FLOW
 ***********************************************************/
// Called after the user clicks "Next Level" but BEFORE the next level actually starts
function startFrenzyAfterLevel() {
  frenzyActive = true;

  // 1) Clear everything from the previous level
  clearCupAndCustomers();

  // 2) Pick a random fruit
  frenzyFruitType = standardFruits[Math.floor(Math.random() * standardFruits.length)];

  // 3) Show a short "Frenzy" banner for 2 seconds (but no dropping yet)
  const frenzyOverlay = document.getElementById('frenzyOverlay');
  frenzyOverlay.style.display = 'block';
  frenzyOverlay.innerHTML = `
    <h1>FRUIT FRENZY!</h1>
    <p>Get ready to merge <b>${frenzyFruitType}</b> soon...</p>
  `;

  // Wait 2 seconds, then hide banner and start 10s auto-drop
  frenzyPhaseTimeout = setTimeout(() => {
    // Hide banner so the cup is fully visible
    frenzyOverlay.style.display = 'none';

    // Start the 10s spree
    startFrenzySpawning();
  }, 2000);
}

function startFrenzySpawning() {
  if (!frenzyActive) return;

  // We could show an updated overlay or just keep it hidden:
  // const frenzyOverlay = document.getElementById('frenzyOverlay');
  // frenzyOverlay.style.display = 'block';
  // frenzyOverlay.innerHTML = `
  //   <h1>FRUIT FRENZY!</h1>
  //   <p>Merge as many <b>${frenzyFruitType}</b> as you can in 10 seconds!</p>
  // `;

  // Every 300ms, drop that single fruit
  autoSpawnInterval = setInterval(spawnFrenzyFruit, 100);

  // End after 10s
  frenzyPhaseTimeout = setTimeout(endFruitFrenzy, 15000);
}

function spawnFrenzyFruit() {
  if (!frenzyActive) return;
  let fruit = createFruit(guideLine.x, guideLine.y, frenzyFruitType, 0);
  Matter.Body.setAngularVelocity(fruit, (Math.random() - 0.5) * 0.4);
  Matter.Body.setVelocity(fruit, { x: (Math.random() - 0.5), y: 0 });
  Composite.add(world, fruit);
}

function endFruitFrenzy() {
  if (!frenzyActive) return;
  frenzyActive = false;

  clearInterval(autoSpawnInterval);
  clearTimeout(frenzyPhaseTimeout);

  // Hide overlay
  document.getElementById('frenzyOverlay').style.display = 'none';

  // Empty the cup again
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      Composite.remove(world, body);
    }
  });

  // Now actually start the next level
  resetCustomers();
}

function endFrenzyImmediately() {
  frenzyActive = false;
  
  clearInterval(autoSpawnInterval);
  clearTimeout(frenzyPhaseTimeout);

  document.getElementById('frenzyOverlay').style.display = 'none';

  // Remove any fruits in the cup
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      Composite.remove(world, body);
    }
  });

  // Start the next level directly, no popup
  resetCustomers();
}

function resetCustomers() {
  if (!storedCustomers[level]) {
    // Generate and store customers if not already saved for the level
    storedCustomers[level] = generateLevel(level);
  }

  // Use stored customers
  customers = JSON.parse(JSON.stringify(storedCustomers[level]));

  // Clear the cup by removing all fruits
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      Composite.remove(world, body);
    }
  });

  console.log("Cup cleared + customers reset for level " + level);
    // Update barn visibility for the new level
    updateBarnVisibility(level);
}

let barnFadedOut = false; // Track if the barn has already faded out

function updateBarnVisibility(level) {
  const barnCover = document.getElementById("barn-cover");

  if (level === 4 && !barnFadedOut) {
    // Fade out at level 5
    barnCover.style.opacity = 0; // Start fade-out
    barnFadedOut = true; // Mark as faded out to prevent further changes
    setTimeout(() => {
      barnCover.style.display = "none"; // Fully hide after fade-out
    }, 1000); // Match the transition duration
  }
}

function resetLevel() {
  console.log(`Restarting level ${level}...`);
  resetCustomers();

  // Clear the cup
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      Composite.remove(world, body);
    }
  });

  // Log level start to Firebase
  firebase.analytics().logEvent("level_start", {
    level_number: level,
  });

  console.log("Level restarted with the same customer requests.");
}

    // -------------- CREATE FRUIT (key function) --------------

    // 1) Tweak engine iterations
engine.positionIterations = 10;
engine.velocityIterations = 6;

    function createFruit(x, y, fruitType, level) {
  let type = fruitHierarchy[fruitType];
  let lvlData = type.levels[level];
  let collisionRadius = lvlData.radius * 0.8; // slight inflate for snug collisions
  let fruit = Bodies.circle(x, y, collisionRadius, {
    restitution: 0.5,
    label: fruitType,
    render: {
      visible: false
    }
  });

  fruit.fruitType = fruitType;
  fruit.fruitLevel = level;
  fruit.hierarchyText = (level + 1);

  // If this fruit has both an "Open" and "Closed" texture loaded, let's treat it as "blinking."
  let hasOpenTex = textures[fruitType + "_Open"];
  let hasClosedTex = textures[fruitType + "_Closed"];
  if (hasOpenTex && hasClosedTex) {
    // Assign a per-body blinkData
    fruit.blinkData = {
  state: "Open",          // Start with the "Open" state
  timer: 0,               // Timer to track state duration
  openThreshold: 200 + Math.floor(Math.random() * 100),  // Longer "Open" duration (200–300 frames)
  closedThreshold: 30 + Math.floor(Math.random() * 20)   // Shorter "Closed" duration (30–50 frames)
};

  }

  return fruit;
} 
function dropFruit() {

  if (frenzyActive) {
        // If we want to DISABLE manual dropping during Frenzy:
        return;
      }
  let curr = currentFruit();
  let fruit = createFruit(guideLine.x, guideLine.y, curr.type, curr.level);

  // Give it a slight random spin & horizontal velocity
  Matter.Body.setAngularVelocity(fruit, (Math.random() - 0.5) * 0.2);
  Matter.Body.setVelocity(fruit, { x: (Math.random() - 0.5) * 0.5, y: 0 });

  Composite.add(world, fruit);
  analyzeCup();
  upcomingFruits.shift();
  upcomingFruits.push(getRandomFruitEntry());
}
 
    var upcomingFruits = [
      getRandomFruitEntry(),
      getRandomFruitEntry(),
      getRandomFruitEntry(),
      getRandomFruitEntry(),
      getRandomFruitEntry()
    ];
    function currentFruit(){ return upcomingFruits[0]; }
 
    function getRandomFruitEntry() {
  // pick from standardFruits so that Mango, Pineapple, Lychee never appear randomly
  const randomType = standardFruits[Math.floor(Math.random() * standardFruits.length)];
  return {
    type: randomType,
    level: 0
  };
}

 
    function analyzeCup(){
      Composite.allBodies(world).forEach((body)=>{
        if(body.fruitType){
          body.highlight=false;
          customers.forEach(customer=>{
            if(!customer.fulfilled){
              customer.requests.forEach(req=>{
                if(!req.fulfilled && req.fruit===body.fruitType && req.level===body.fruitLevel){
                  body.highlight=true;
                }
              });
            }
          });
          // if fruit falls out bottom => loss
          if (body.position.y > 1000 + body.circleRadius) {
  if (frenzyActive) {
    // END FRENZY IMMEDIATELY — NO "YOU LOST" POPUP
    endFrenzyImmediately();
  } else {
    // Normal game flow
    showLossPopup();
  }
}
        }
      });
    }
 
    function showLossPopup() {
  if (document.getElementById('popupOverlay')) return;

  var overlay = document.createElement('div');
  overlay.id = 'popupOverlay';
  document.body.appendChild(overlay);

  var popup = document.createElement('div');
  popup.className = 'popupBox';
  popup.innerHTML = `
    <h2>You Lost!</h2>
    </p></p></p></p></p></p></p></p></p></p></p></p></p>
    <p>A fruit fell out of the cup.</p>
    <button id="restartLevelBtn">Restart Level</button>
  `;


  overlay.appendChild(popup);

  var restartLevelButton = document.getElementById('restartLevelBtn');
  if (restartLevelButton) {
    restartLevelButton.addEventListener('click', function () {
      if (overlay) document.body.removeChild(overlay);
      resetLevel();
    });
  }
}
 
function resetLevel() {
  console.log(`Restarting level ${level}...`);
  resetCustomers();
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      Composite.remove(world, body);
    }
  });

  // Log level start to Firebase
  firebase.analytics().logEvent('level_start', {
    level_number: level,
  });

  console.log("Level restarted and cup cleared.");
}

let consecutiveMerges = 0;
let lastMergeTime = Date.now();
const mergeTimeout = 2000; // Timeout in ms to reset merge streak

function mergeFruits(bodyA, bodyB) {
  let fruitType = bodyA.fruitType;
  let level = bodyA.fruitLevel;
  let typeData = fruitHierarchy[fruitType];
  let maxLevel = typeData.levels.length - 1;

    // Play merge sound
    const mergeSound = document.getElementById("mergeSound");
  mergeSound.currentTime = 0; // Reset playback for overlapping merges
  mergeSound.play();


  Composite.remove(world, bodyA);
  Composite.remove(world, bodyB);

  // Increment consecutive merges if within timeout
  const now = Date.now();
  if (now - lastMergeTime < mergeTimeout) {
    consecutiveMerges++;
  } else {
    consecutiveMerges = 1; // Reset to 1 for a new streak
  }
  lastMergeTime = now;

  // Show multiplier text
  if (consecutiveMerges > 1) {
    createFloatingText(`${consecutiveMerges}x`, (bodyA.position.x + bodyB.position.x) / 2, (bodyA.position.y + bodyB.position.y) / 2);
  }

  if (level === maxLevel) {
    coins += 5;
    console.log("5 coins added (max level merge). total:" + coins);
  } else {
    let newX = (bodyA.position.x + bodyB.position.x) / 2;
    let newY = (bodyA.position.y + bodyB.position.y) / 2;
    let merged = createFruit(newX, newY, fruitType, level + 1);
    Composite.add(world, merged);
  }
} 

const floatingTexts = [];

function createFloatingText(text, x, y) {
  floatingTexts.push({ text, x, y, opacity: 1, time: Date.now() });
}

function drawFloatingTexts(ctx) {
  const now = Date.now();
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    const elapsed = (now - ft.time) / 1000;
    ft.opacity -= elapsed * 0.1; // Fade out over 2 seconds
    ft.y -= elapsed * 20; // Move up slightly

    if (ft.opacity <= 0) {
      floatingTexts.splice(i, 1); // Remove when fully faded
    } else {
      ctx.globalAlpha = ft.opacity;
      ctx.font = "40px 'Fredoka One', sans-serif";
      ctx.fillStyle = "yellow";
      ctx.textAlign = "center";
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.globalAlpha = 1; // Reset alpha
    }
  }
}

    Events.on(engine,'collisionStart',(event)=>{
      let pairs= event.pairs;
      pairs.forEach((pair)=>{
        let bodyA= pair.bodyA;
        let bodyB= pair.bodyB;
        if(bodyA.fruitType && bodyB.fruitType){
          if(bodyA.fruitType=== bodyB.fruitType && bodyA.fruitLevel=== bodyB.fruitLevel){
            mergeFruits(bodyA,bodyB);
          }
        }
        if(bodyA.fruitType) checkCustomerRequests(bodyA);
        if(bodyB.fruitType) checkCustomerRequests(bodyB);
      });
    });
 

    function checkCustomerRequests() {
  // 1) If we are in Frenzy, do not process customers at all
  if (frenzyActive) return;

  customers.forEach(customer => {
    if (!customer.fulfilled) {
      const allInCup = customer.requests.every(req =>
        Composite.allBodies(world).some(body =>
          body.fruitType === req.fruit && body.fruitLevel === req.level
        )
      );
      if (allInCup) {
        customer.requests.forEach(req => {
          // remove them from the cup
          Composite.allBodies(world).forEach(body => {
            if (body.fruitType === req.fruit && body.fruitLevel === req.level) {
              Composite.remove(world, body);
            }
          });
        });
        customer.fulfilled = true;
      }
    }
  });

  if (customers.every(c => c.fulfilled)) {
    showPopupAndProceed();
  }
}
 
    function updateUserProperties() {
  firebase.analytics().setUserProperties({
    total_coins: coins,
    max_level: level,
  });
}

function showPopupAndProceed() {
  if (document.getElementById('popupOverlay')) return;
  gamePaused = true;
  coins += 10;

  firebase.analytics().logEvent('level_complete', { level_number: level, coins_earned: 10 });
  updateUserProperties();

  const overlay = document.createElement('div');
  overlay.id = 'popupOverlay';
  document.body.appendChild(overlay);

  const popup = document.createElement('div');
  popup.className = 'popupBox';
  popup.innerHTML = `
    <h2>Level Complete!</h2>
    <p>You have earned 10 coins!</p>
    <p>Total Coins: ${coins}</p>
    <button id="nextLevelBtn">Next Level</button>
  `;
  overlay.appendChild(popup);

  const nextLevelButton = document.getElementById('nextLevelBtn');
  if (nextLevelButton) {
    nextLevelButton.addEventListener('click', () => {
      document.body.removeChild(overlay);
      gamePaused = false;
      level++;
      updateBarnVisibility(level);

      // If we want Frenzy at level 2 (for testing):
      if (level % 3 === 0) {
        startFrenzyAfterLevel();
      } else {
        // otherwise proceed normally
        resetCustomers();
      }
    });
  }
}
 
    // Key controls
    var moveLeft=false, moveRight=false, moveSpeed=5;
    var isSpacePressed=false, canDropFruit=true, fruitCooldownTime=300;
 
    document.addEventListener('keydown', function(event){
      if(event.key==='ArrowLeft'){
        moveLeft=true;
      } else if(event.key==='ArrowRight'){
        moveRight=true;
      } else if(event.key===' ' && !isSpacePressed && canDropFruit){
        isSpacePressed=true;
        canDropFruit=false;

        // If not frenzy, do normal drop
        dropFruit();

        setTimeout(()=>{ canDropFruit=true; }, fruitCooldownTime);
      }
    });
    document.addEventListener('keyup', function(event){
      if(event.key==='ArrowLeft') moveLeft=false;
      if(event.key==='ArrowRight') moveRight=false;
      if(event.key===' ') isSpacePressed=false;
    });
 
    // ------------------- Canvas render loop -------------------
    (function renderLoop(){
      updateBlinkStates();
      if(moveLeft && guideLine.x> cupCenterX - (cupWidthTop/2)+20) guideLine.x-= moveSpeed;
      if(moveRight && guideLine.x< cupCenterX + (cupWidthTop/2)-20) guideLine.x+= moveSpeed;
 
      var ctx= render.context;
      ctx.clearRect(0,0, render.canvas.width, render.canvas.height);
      Render.world(render);
 
      drawGuideLine(ctx);
      drawUpcomingFruits(ctx);
      drawCustomers(ctx);
      drawCurrentLevel(ctx);
      displayCoins(ctx);
      displaySeeds(ctx);  // <--- new function to show seeds below coins
 
      drawFruitsWithText(ctx);
      drawFloatingTexts(ctx); // Render floating texts

      analyzeCup();
 
      requestAnimationFrame(renderLoop);
    })();
 
    function drawGuideLine(ctx) {
      if (frenzyActive) return;

    // Draw the guide line
    ctx.beginPath();
    ctx.moveTo(guideLine.x, guideLine.y); // Use guideLine.y instead of a hardcoded value
    ctx.lineTo(guideLine.x, guideLine.y + 200); // Extend downward
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Get the current fruit data
    let curr = currentFruit();
    let type = fruitHierarchy[curr.type];
    let lvlData = type.levels[curr.level];

    // Check if the fruit has a texture
    if (lvlData.texture && textures[curr.type]) {
        // Draw the texture if available and loaded
        if (textures[curr.type].complete) {
            ctx.drawImage(
                textures[curr.type],
                guideLine.x - lvlData.radius,
                guideLine.y - lvlData.radius,
                lvlData.radius * 2,
                lvlData.radius * 2
            );
        }
    } else {
        // Draw a simple circle if no texture is available
        ctx.beginPath();
        ctx.arc(guideLine.x, guideLine.y, lvlData.radius, 0, 2 * Math.PI);
        ctx.fillStyle = lvlData.color;
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.stroke();
    }

    // Draw the fruit level text
    // const textColor = getContrastColor(lvlData.color);
    // ctx.font = "16px 'Sour Gummy', sans-serif";
    // ctx.fillStyle = textColor;
    // ctx.textAlign = "center";
    // ctx.textBaseline = "middle";
    // ctx.fillText((curr.level + 1), guideLine.x, guideLine.y);

    // Draw the fruit type text
    ctx.fillStyle = "black";
    ctx.font = "18px 'Sour Gummy', sans-serif";
    ctx.fillText(curr.type, guideLine.x, guideLine.y+30);
}
 
    function drawUpcomingFruits(ctx) {
      if (frenzyActive) return;

    let startX = 60;
    let startY = 350;
    let verticalSpacing = 70;

    // Title
    ctx.font = "20px 'Fredoka One', sans-serif";
    ctx.fillStyle = "black";
    ctx.fillText("Upcoming:", startX + 10, startY - 50);

    for (let i = 0; i < upcomingFruits.length; i++) {
      let fruitData = upcomingFruits[i];
        let type = fruitHierarchy[fruitData.type];
        let lvlData = type.levels[fruitData.level];
        let yPos = startY + i * verticalSpacing;

        // If a texture is defined and preloaded, draw it
        if (lvlData.texture && textures[fruitData.type]) {
            // OPTIONAL: Check if the image is fully loaded
            if (textures[fruitData.type].complete) {
                ctx.drawImage(
                    textures[fruitData.type],
                    startX - lvlData.radius,
                    yPos - lvlData.radius,
                    lvlData.radius * 2,
                    lvlData.radius * 2
                );

                // Draw fruit-level text on top (optional)
                const textColor = getContrastColor(lvlData.color);
                ctx.font = "16px 'Sour Gummy', sans-serif";
                ctx.fillStyle = textColor;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText((fruitData.level + 1), startX, yPos);
            } 
            // else { // If not complete, optionally do a fallback
            //     // e.g., draw a placeholder circle or do nothing
            // }
        } else {
            // Draw a simple colored circle if no texture or not loaded
            ctx.beginPath();
            ctx.arc(startX, yPos, lvlData.radius, 0, 2 * Math.PI);
            ctx.fillStyle = lvlData.color;
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.stroke();

            const textColor = getContrastColor(lvlData.color);
            ctx.font = "16px 'Sour Gummy', sans-serif";
            ctx.fillStyle = textColor;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText((fruitData.level + 1), startX, yPos);
        }
    }
}

function drawCustomers(ctx) {
    let startX = 250;
    let startY = cupCenterY + cupHeight / 2 - 530;
    let horizontalSpacing = 100;

    // Title
    ctx.font = "20px 'Fredoka One', sans-serif";
    ctx.fillStyle = "black";
    ctx.fillText("Customer Orders:", startX + 30, startY - 30);

    customers.forEach((customer, index) => {
        let xPos = startX + index * horizontalSpacing;
        let yPos = startY;
        ctx.fillStyle = customer.fulfilled ? "green" : "black";
        ctx.fillText(`Customer ${customer.id}`, xPos + 30, yPos);

        let centerX = xPos;
        let centerY = yPos + 40;
        let radius = 30;
        let angleStep = (2 * Math.PI) / customer.requests.length;

        customer.requests.forEach((request, reqIndex) => {
            let type = fruitHierarchy[request.fruit];
            let lvlData = type.levels[request.level];
            let fruitX = centerX + radius * Math.cos(reqIndex * angleStep);
            let fruitY = centerY + radius * Math.sin(reqIndex * angleStep);

            let inCup = Composite.allBodies(world).some(
                (body) => body.fruitType === request.fruit && body.fruitLevel === request.level
            );

            // If a texture exists and is loaded, draw it
            if (lvlData.texture && textures[request.fruit] && textures[request.fruit].complete) {
                ctx.drawImage(
                    textures[request.fruit],
                    fruitX - lvlData.radius,
                    fruitY - lvlData.radius,
                    lvlData.radius * 2,
                    lvlData.radius * 2
                );

                // Highlight fulfilled requests with a border
                if (inCup && !customer.fulfilled) {
                    ctx.beginPath();
                    ctx.arc(fruitX, fruitY, lvlData.radius + 3, 0, 2 * Math.PI);
                    ctx.strokeStyle = "green";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            } else {
                // Fallback: Draw a simple colored circle if no texture exists
                ctx.beginPath();
                ctx.arc(fruitX, fruitY, lvlData.radius, 0, 2 * Math.PI);
                ctx.fillStyle = customer.fulfilled ? "grey" : lvlData.color;
                ctx.fill();
                ctx.strokeStyle = inCup && !customer.fulfilled ? "green" : "black";
                ctx.lineWidth = inCup && !customer.fulfilled ? 3 : 1;
                ctx.stroke();
            }

            // Draw fruit-level text on top
            const textColor = getContrastColor(lvlData.color);
            const effectiveColor = customer.fulfilled ? "#aaaaaa" : lvlData.color;
            const txtFillColor = getContrastColor(effectiveColor);
            ctx.font = "16px 'Sour Gummy', sans-serif";
            ctx.fillStyle = txtFillColor;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(request.level + 1, fruitX, fruitY);
        });
    });
}

function updateBlinkStates() {
  Composite.allBodies(world).forEach(body => {
    if (!body.blinkData) return;

    body.blinkData.timer++;

    if (body.blinkData.state === "Open" && body.blinkData.timer >= body.blinkData.openThreshold) {
      body.blinkData.state = "Closed";
      body.blinkData.timer = 0;
    } else if (body.blinkData.state === "Closed" && body.blinkData.timer >= body.blinkData.closedThreshold) {
      body.blinkData.state = "Open";
      body.blinkData.timer = 0;
    }
  });
}
    function drawCurrentLevel(ctx){
      ctx.font="30px 'Fredoka One', sans-serif";
      ctx.fillStyle="black";
      ctx.fillText("Level: "+level,80,30);
    }
 
    function displayCoins(ctx){
      ctx.font="30px 'Fredoka One', sans-serif";
      ctx.fillStyle="black";
      ctx.fillText("Coins: "+ coins,82,80);
    }

    // (1) Draw Seeds below coins
    function displaySeeds(ctx){
      ctx.font="30px 'Fredoka One', sans-serif";
      ctx.fillStyle="black";
      // We'll draw it around y=130
      ctx.fillText("Seeds: "+ seeds, 110, 130);
    }

    // Add a click listener to detect clicks on the Seeds area in the canvas
    render.canvas.addEventListener('click', (e) => {
      // get bounding rect for the canvas
      const rect = render.canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      // Rough bounding box for "Seeds" text: x ~ 82..250, y ~ 100..140
      if (clickX >= 82 && clickX <= 250 && clickY >= 100 && clickY <= 140) {
        openSeedsPurchasePopup();
      }
    });

    // (2) Open a popup that allows user to buy seeds
    function openSeedsPurchasePopup(){
      // If a popup is already open, do nothing
      if(document.getElementById('popupOverlay')) return;

      let overlay = document.createElement('div');
      overlay.id = 'popupOverlay';
      document.body.appendChild(overlay);

      let popup = document.createElement('div');
      popup.className = 'popupBox';
      popup.innerHTML = `
        <h2>Buy Seeds</h2>
        </p>
        <p>Each seed costs 10 coins. You have ${coins} coins.</p>
        <p>Max seeds you can afford: ${Math.floor(coins/10)}</p>
        <input type="range" id="seedRange" min="0" max="${Math.floor(coins/10)}" value="0" />
        <span id="seedRangeValue">0</span>
      
        <button id="purchaseSeedsBtn">Purchase</button>
        <button id="closePopupBtn">Cancel</button>
      `;
      overlay.appendChild(popup);

      // Range input listener
      let rangeEl = document.getElementById('seedRange');
      let rangeValueEl = document.getElementById('seedRangeValue');
      rangeEl.addEventListener('input', () => {
        rangeValueEl.textContent = rangeEl.value;
      });

      // Purchase button
      let purchaseBtn = document.getElementById('purchaseSeedsBtn');
      purchaseBtn.addEventListener('click', () => {
        let amountToBuy = parseInt(rangeEl.value);
        if (amountToBuy > 0) {
          let cost = amountToBuy * 10;
          coins -= cost;
          seeds += amountToBuy;
        }
        document.body.removeChild(overlay);
      });

      // Close/cancel button
      let closeBtn = document.getElementById('closePopupBtn');
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
    }
 
    function drawFruitsWithText(ctx) {
  Composite.allBodies(world).forEach(body => {
    if (body.fruitType) {
      const posX = body.position.x;
      const posY = body.position.y;
      const angle = body.angle;
      const radius = fruitHierarchy[body.fruitType].levels[body.fruitLevel].radius;
      const bgColor = fruitHierarchy[body.fruitType].levels[body.fruitLevel].color;

      // Highlight ring
      if (body.highlight) {
        ctx.beginPath();
        ctx.arc(posX, posY, radius + 3, 0, 2 * Math.PI);
        ctx.strokeStyle = "green";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Canvas transform to rotate with physics
      ctx.save();
      ctx.translate(posX, posY);
      ctx.rotate(angle);

      if (body.blinkData) {
        // If this body is blinking
        const blinkState = body.blinkData.state; // "Open" or "Closed"
        const texKey = body.fruitType + "_" + blinkState;
        const texture = textures[texKey];

        if (texture && texture.complete) {
          ctx.drawImage(texture, -radius, -radius, radius * 2, radius * 2);
        } else {
          // fallback circle
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, 2 * Math.PI);
          ctx.fillStyle = bgColor;
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        }

      } else {
        // Non-blinking or fruit with no blinkData
        let defaultTexture = fruitHierarchy[body.fruitType].levels[body.fruitLevel].texture;
        if (defaultTexture && textures[body.fruitType] && textures[body.fruitType].complete) {
          ctx.drawImage(textures[body.fruitType], -radius, -radius, radius * 2, radius * 2);
        } else {
          // Fallback circle
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, 2 * Math.PI);
          ctx.fillStyle = bgColor;
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        }
      }

      ctx.restore(); // reset transforms

      // Fruit-level text (non-rotated)
      const textColor = getContrastColor(bgColor);
      ctx.font = "16px 'Sour Gummy', sans-serif";
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(body.hierarchyText, posX, posY);
    }
  });
}
    function getContrastColor(hexColor){
      // handle short color or no '#'
      if(hexColor[0] === '#') hexColor = hexColor.slice(1);
      if(hexColor.length < 6) {
        // for simplicity, just return black
        return "black";
      }
      let r= parseInt(hexColor.slice(0,2),16);
      let g= parseInt(hexColor.slice(2,4),16);
      let b= parseInt(hexColor.slice(4,6),16);
      let luminance= 0.2126*(r/255)+ 0.7152*(g/255)+ 0.0722*(b/255);
      return luminance>0.5? "black": "white";
    }
 
    /**************************************************************
     * 3) PACHINKO CODE
     **************************************************************/


// Example usage: Hide the barn after level 5
    if (level > 1) {
      toggleBarnCover(false); // Show Pachinko
    } else {
      toggleBarnCover(true);  // Keep Barn covering
    }
    
     const pachinkoCanvas = document.getElementById("pachinkoCanvas");
    const pCtx = pachinkoCanvas.getContext("2d");
 
    let pWidth = pachinkoCanvas.clientWidth;
    let pHeight= pachinkoCanvas.clientHeight;
    // For hover detection
    let mousePos = { x: 0, y: 0 };
    let hoverFruit = null;

    pachinkoCanvas.width= pWidth;
    pachinkoCanvas.height= pHeight;
 
    let pachinkoFieldHeight= 300;
    let gardenHeight= pHeight - pachinkoFieldHeight;

    // We REMOVE ballCount=20; we use the global seeds variable instead
    // We'll rename the old "seeds" object that stored Mango/Pineapple/Lichi to basketProgress
    const basketProgress = { Mango:0, Pineapple:0, Lychee:0 };
    let gardenFruits= { Mango:false, Pineapple:false, Lychee:false };
   // NEW: Add harvestedFruits
    let harvestedFruits = { Mango: false, Pineapple: false, Lychee: false }; 

    const balls= [];
    const pegs= [];
 
    let baskets=[
      { x:0,y: pachinkoFieldHeight-20, w:60,h:20, type:"Mango"     },
      { x:60,y:pachinkoFieldHeight-20, w:60,h:20, type:"Pineapple" },
      { x:120,y:pachinkoFieldHeight-20, w:60,h:20, type:"Lychee"    },
      { x:180,y:pachinkoFieldHeight-20, w:60,h:20, type:null       }
    ];
    let basketSpeed= 1.5;
    let basketDirection=1;
 
    const ballRadius2= 8;
    const pegRadius2= 4;
    const gravity2= 0.3;
    const damping2= 0.8;
    const friction2= 0.98;
 
    let dropX= pWidth/2;
    let dropSpeed2=2;
    let dropDir2= 1;
 
    function createPegs2(){
      pegs.length=0;
      let spacingX=40;
      let spacingY=40;
      let offsetX=20;
      let offsetY=40;
      let cols= Math.floor((pWidth-offsetX)/ spacingX);
      let rows= Math.floor((pachinkoFieldHeight - offsetY)/ spacingY)-1;
      for(let r=0; r<rows; r++){
        for(let c=0; c<cols; c++){
          let px= offsetX + c*spacingX + (r%2 ? spacingX/2:0);
          let py= offsetY + r*spacingY;
          pegs.push({x:px,y:py});
        }
      }
    }
 
    function initPachinko(){
      createPegs2();
      let totalW= baskets.length*60;
      let startX= (pWidth - totalW)/2;
      baskets.forEach((bk,i)=>{
        bk.x= startX + i*60;
        bk.y= pachinkoFieldHeight- bk.h;
      });
      dropX= pWidth/2;
    }
    initPachinko();
 
    function pachinkoLoop(){
      updatePachinko();
      drawPachinko();
      requestAnimationFrame(pachinkoLoop);
    }
    pachinkoLoop();
 
    function updatePachinko(){
      dropX+= dropSpeed2*dropDir2;
      if(dropX<15){ dropX=15; dropDir2=1;}
      if(dropX> pWidth-15){ dropX= pWidth-15; dropDir2=-1;}
 
      baskets.forEach(b=> b.x+= basketSpeed* basketDirection);
      let leftB= baskets[0].x;
      let rightB= baskets[baskets.length-1].x+ baskets[baskets.length-1].w;
      if(leftB<0){
        let shift= -leftB;
        baskets.forEach(b=> b.x+=shift);
        basketDirection=1;
      } else if(rightB> pWidth){
        let shift= pWidth- rightB;
        baskets.forEach(b=> b.x+= shift);
        basketDirection=-1;
      }
 
      for(let i= balls.length-1; i>=0; i--){
        let ball= balls[i];
        ball.vy+= gravity2;
        ball.vx*= friction2;
        ball.x+= ball.vx;
        ball.y+= ball.vy;
 
        // Peg collisions
        for(let peg of pegs){
          let dx= ball.x- peg.x;
          let dy= ball.y- peg.y;
          let dist= Math.sqrt(dx*dx + dy*dy);
          if(dist< ballRadius2+ pegRadius2){
            let angle= Math.atan2(dy,dx);
            let overlap= (ballRadius2+ pegRadius2)-dist;
            ball.x+= Math.cos(angle)*overlap;
            ball.y+= Math.sin(angle)*overlap;
 
            let nx= dx/dist;
            let ny= dy/dist;
            let proj= ball.vx*nx + ball.vy*ny;
            ball.vx-= 2*proj*nx;
            ball.vy-= 2*proj*ny;
            ball.vx*= damping2;
            ball.vy*= damping2;
          }
        }
 
        // Left/Right walls
        if(ball.x< ballRadius2){
          ball.x= ballRadius2;
          ball.vx=-ball.vx*damping2;
        }
        if(ball.x> pWidth- ballRadius2){
          ball.x= pWidth- ballRadius2;
          ball.vx=-ball.vx*damping2;
        }
 
        // Reached bottom (baskets)
        if (ball.y > pachinkoFieldHeight - ballRadius2) {
  for (let bk of baskets) {
    if (ball.x > bk.x && ball.x < bk.x + bk.w) {
      if (bk.type && gardenFruits[bk.type] === false) {
        // 1) Capture old count
        const oldCount = basketProgress[bk.type];
        
        // 2) Increment basket progress
        basketProgress[bk.type]++;
        const newCount = basketProgress[bk.type];
        
        // 3) If the root advanced (e.g. from 0 -> 1, 1 -> 2, etc.), play the sound
        if (newCount > oldCount) {
          const rootEvolveSound = document.getElementById("rootEvolveSound");
          rootEvolveSound.currentTime = 0;    // reset to start if it’s already playing
          rootEvolveSound.play();
        }

        // 4) If we reach 5 seeds => permanently “grown” fruit
        if (basketProgress[bk.type] >= 5) {
          gardenFruits[bk.type] = true;
        }
      }
      break; // break out of the basket loop
    }
  }
  // remove the ball from the array
  balls.splice(i, 1);
}

      }
    }
 
    function drawPachinko(){
      pCtx.clearRect(0,0,pWidth,pHeight);
 
      // Draw pegs
      pCtx.fillStyle='#888';
      for(let peg of pegs){
        pCtx.beginPath();
        pCtx.arc(peg.x, peg.y, pegRadius2,0,2*Math.PI);
        pCtx.fill();
      }
 
      // Draw baskets
      for(let bk of baskets){
        if(!bk.type) pCtx.fillStyle='#444';
        else if(bk.type==='Mango') pCtx.fillStyle='#ffaa00';
        else if(bk.type==='Pineapple') pCtx.fillStyle='#ccff55';
        else if(bk.type==='Lychee') pCtx.fillStyle='#ff66aa';
        pCtx.fillRect(bk.x,bk.y,bk.w,bk.h);
 
        pCtx.fillStyle='#000';
        pCtx.font="14px 'Sour Gummy', sans-serif";
        pCtx.textAlign='center';
        pCtx.textBaseline='middle';
        let label= bk.type? bk.type:"None";
        pCtx.fillText(label, bk.x+ bk.w/2, bk.y+ bk.h/2);
      }
 
      // Draw the balls
      pCtx.fillStyle='#0e9c65';
      for(let b of balls){
        pCtx.beginPath();
        pCtx.arc(b.x,b.y, ballRadius2,0,2*Math.PI);
        pCtx.fill();
      }
 
      // Drop indicator
      pCtx.strokeStyle='#0f0';
      pCtx.beginPath();
      pCtx.moveTo(dropX,0);
      pCtx.lineTo(dropX,30);
      pCtx.stroke();
      pCtx.beginPath();
      pCtx.arc(dropX,30,5,0,2*Math.PI);
      pCtx.fillStyle='#0f0';
      pCtx.fill();
 
      drawGarden();
 
      // Show how many seeds remain (instead of old ballCount)
      pCtx.fillStyle='#000';
      pCtx.font="16px 'Sour Gummy', sans-serif";
      pCtx.fillText(`Seeds left: ${seeds}`, 80, 20);
    }
 

    function drawGarden() {
  pCtx.fillStyle = '#A7C957';
  pCtx.fillRect(0, pachinkoFieldHeight, pWidth, gardenHeight);



  Object.keys(basketProgress).forEach((fruit) => {
    const lane      = lanes[fruit];
    const seedCount = basketProgress[fruit];

    if (seedCount >= 5) {
      // final stage
      const finalKey   = `root_${fruit.toLowerCase()}`;
      const finalImage = textures[finalKey];
      if (finalImage && finalImage.complete) {
        // default size
        let drawWidth  = lane.width;
        let drawHeight = lane.height;

        // Check if user is hovering over this fruit’s bounding box and it’s not harvested
        if (
          !harvestedFruits[fruit] &&
          mousePos.x >= lane.xStart &&
          mousePos.x <= lane.xStart + lane.width &&
          mousePos.y >= lane.yStart &&
          mousePos.y <= lane.yStart + lane.height
        ) {
          // Enlarge the tree by +10 px in each dimension
          drawWidth  += 10;
          drawHeight += 10;
        }

        // Center the “bigger” image so it doesn’t jump around too much
        const offsetX = lane.xStart - (drawWidth - lane.width) / 2;
        const offsetY = lane.yStart - (drawHeight - lane.height) / 2;

        pCtx.drawImage(finalImage, offsetX, offsetY, drawWidth, drawHeight);
      }
    } else {
      // 1..4 seeds => draw root stage
      const stage     = Math.max(1, Math.min(seedCount, 4));
      const stageKey  = `root${stage}`;
      const stageImage = textures[stageKey];
      if (stageImage && stageImage.complete) {
        // you can do the same “hover” enlargement if you want partial growth to be interactive
        pCtx.drawImage(stageImage, lane.xStart - 10, 330, 50, 50);
      }
    }
  });
}

    // Use seeds (currency) to drop pachinko balls
    pachinkoCanvas.addEventListener('click', (e) => {
  const rect = pachinkoCanvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;
  console.log(`pachinkoCanvas clicked at x=${clickX}, y=${clickY}`);

  // 1) If user clicked high up, drop a ball (existing code):
  if (clickY < pachinkoFieldHeight) {
    if (seeds > 0) {
      seeds--;
      balls.push({
        x: dropX,
        y: 30,
        vx: (Math.random() - 0.5) * 3,
        vy: 0
      });
    }
    return;
  }

  // 2) Else check if user clicked on any GROWN fruit
  Object.keys(basketProgress).forEach((fruit) => {
  if (basketProgress[fruit] >= 5 && !harvestedFruits[fruit]) {
    const { xStart, yStart, width, height } = lanes[fruit];

    if (
      clickX >= xStart &&
  clickX <= xStart + 120 &&
  clickY >= yStart &&
  clickY <= yStart + 120
    ) {
      console.log(`Inside bounding box for ${fruit} at [${clickX},${clickY}]`);
      harvestTreeFruit(fruit);
    }
  }
});
});

pachinkoCanvas.addEventListener('mousemove', (e) => {
  const rect = pachinkoCanvas.getBoundingClientRect();
  mousePos.x = e.clientX - rect.left;
  mousePos.y = e.clientY - rect.top;
});
function harvestTreeFruit(fruitName) {
  console.log("Harvesting " + fruitName + " from the garden!");
  console.log("Before splice, upcomingFruits:", JSON.stringify(upcomingFruits));

  // (1) Reset orchard state for this fruit
  basketProgress[fruitName] = 0;
  gardenFruits[fruitName]   = false;
  harvestedFruits[fruitName]= false;
// Then set the new fruit as the immediate drop
upcomingFruits[0] = { type: fruitName, level: 0 };
  // Option 1: Make it the VERY NEXT fruit to drop
  console.log("After splice, upcomingFruits:", JSON.stringify(upcomingFruits));


  // Option 2: Or push it into the queue behind the first
  // upcomingFruits.splice(1, 0, { type: fruitName, level: 0 });

  // Optionally play a “harvest” sound, show a “+1 fruit” text, etc.
  // ...
}

  </script>
</body>
</html>
